Directory structure:
└── maquizhpi-cemae/
    ├── README.md
    ├── next-env.d.ts
    ├── next.config.js
    ├── package.json
    ├── postcss.config.js
    ├── tailwind.config.js
    ├── tsconfig.json
    ├── .eslintrc.json
    ├── controllers/
    │   ├── contexts/
    │   │   └── auth_context.ts
    │   ├── firebase/
    │   │   ├── config.ts
    │   │   └── uploadFile.ts
    │   ├── hooks/
    │   │   ├── use_auth.ts
    │   │   ├── use_local_storage.ts
    │   │   ├── use_no_scroll.ts
    │   │   └── use_window_size.ts
    │   ├── mongo/
    │   │   ├── bodegas/
    │   │   │   ├── create.ts
    │   │   │   ├── list.ts
    │   │   │   ├── read.ts
    │   │   │   └── update.ts
    │   │   ├── calibracion/
    │   │   │   ├── create.ts
    │   │   │   ├── delete.ts
    │   │   │   ├── list.ts
    │   │   │   ├── read.ts
    │   │   │   └── update.ts
    │   │   ├── herramientas/
    │   │   │   ├── create.ts
    │   │   │   ├── delete.ts
    │   │   │   ├── list.ts
    │   │   │   ├── read.ts
    │   │   │   └── update.ts
    │   │   ├── modelos/
    │   │   │   ├── create.ts
    │   │   │   ├── list.ts
    │   │   │   ├── read.ts
    │   │   │   └── update.ts
    │   │   ├── solicitudes/
    │   │   │   ├── create.ts
    │   │   │   ├── delete.ts
    │   │   │   ├── list.ts
    │   │   │   ├── read.ts
    │   │   │   └── update.ts
    │   │   ├── ubicaciones/
    │   │   │   ├── create.ts
    │   │   │   ├── list.ts
    │   │   │   ├── read.ts
    │   │   │   └── update.ts
    │   │   └── user/
    │   │       ├── create.ts
    │   │       ├── delete.ts
    │   │       ├── list.ts
    │   │       ├── read.ts
    │   │       └── update.ts
    │   ├── styles/
    │   │   ├── global.ts
    │   │   └── theme.ts
    │   └── utils/
    │       ├── check_permissions.ts
    │       ├── constants.ts
    │       ├── formated_date.ts
    │       ├── http_client.ts
    │       └── upload_solicitude_images.ts
    ├── database/
    │   ├── schemas.ts
    │   └── connect/
    │       └── mongo.ts
    ├── models/
    │   └── index.d.ts
    ├── pages/
    │   ├── _app.tsx
    │   ├── _document.tsx
    │   ├── auditory.tsx
    │   ├── configuration.tsx
    │   ├── index.tsx
    │   ├── login.tsx
    │   ├── recuperar.tsx
    │   ├── registro.tsx
    │   ├── api/
    │   │   ├── auditory.ts
    │   │   ├── login.ts
    │   │   ├── upload.ts
    │   │   ├── bodegas/
    │   │   │   ├── [id].ts
    │   │   │   └── index.ts
    │   │   ├── calibracion/
    │   │   │   ├── [id].ts
    │   │   │   └── index.ts
    │   │   ├── herramientas/
    │   │   │   ├── [id].ts
    │   │   │   └── index.ts
    │   │   ├── modelos/
    │   │   │   ├── [id].ts
    │   │   │   └── index.ts
    │   │   ├── solicitudes/
    │   │   │   ├── [id].ts
    │   │   │   └── index.ts
    │   │   ├── ubicaciones/
    │   │   │   ├── [id].ts
    │   │   │   └── index.ts
    │   │   └── user/
    │   │       ├── [id].ts
    │   │       └── index.ts
    │   ├── bodegas/
    │   │   ├── index.tsx
    │   │   ├── create/
    │   │   │   └── index.tsx
    │   │   ├── editar/
    │   │   │   └── [id].tsx
    │   │   └── show/
    │   │       └── [id].tsx
    │   ├── calibracion/
    │   │   ├── index.tsx
    │   │   ├── create/
    │   │   │   └── index.tsx
    │   │   └── edit/
    │   │       └── [id].tsx
    │   ├── components/
    │   │   ├── pdf_container.tsx
    │   │   ├── sidebar.tsx
    │   │   ├── toastify.tsx
    │   │   ├── loading_container/
    │   │   │   ├── index.tsx
    │   │   │   └── style.tsx
    │   │   ├── modals/
    │   │   │   ├── confirm.tsx
    │   │   │   ├── modalModelos.tsx
    │   │   │   ├── modalUbicaciones.tsx
    │   │   │   └── user.tsx
    │   │   ├── tab_container/
    │   │   │   ├── index.tsx
    │   │   │   └── styles.tsx
    │   │   └── tree_table/
    │   │       ├── index.tsx
    │   │       └── styles.tsx
    │   ├── layouts/
    │   │   ├── role_layout.tsx
    │   │   ├── session_layout.tsx
    │   │   ├── config/
    │   │   │   ├── modelos/
    │   │   │   │   └── index.tsx
    │   │   │   ├── ubicaciones/
    │   │   │   │   └── index.tsx
    │   │   │   └── users/
    │   │   │       └── index.tsx
    │   │   ├── login/
    │   │   │   └── index.tsx
    │   │   └── register/
    │   │       └── index.tsx
    │   └── solicitudes/
    │       ├── index.tsx
    │       ├── create/
    │       │   └── index.tsx
    │       ├── createForClient/
    │       │   └── index.tsx
    │       ├── edit/
    │       │   └── [id].tsx
    │       └── reporte/
    │           └── [id].tsx
    ├── public/
    │   └── image/
    └── styles/
        ├── global.css
        └── Home.module.css

================================================
FILE: README.md
================================================
# Example app with styled-components

This example features how you use a different styling solution than [styled-jsx](https://github.com/vercel/styled-jsx) that also supports universal styles. That means we can serve the required styles for the first render within the HTML and then load the rest in the client. In this case we are using [styled-components](https://github.com/styled-components/styled-components).

This example uses the Rust-based [SWC](https://nextjs.org/docs/advanced-features/compiler#styled-components) in Next.js for better performance than Babel.

Currently, only the `ssr` and `displayName` transforms have been implemented. These two transforms are the main requirement for using `styled-components` in Next.js.

## Deploy your own

Deploy the example using [Vercel](https://vercel.com?utm_source=github&utm_medium=readme&utm_campaign=next-example) or preview live with [StackBlitz](https://stackblitz.com/github/vercel/next.js/tree/canary/examples/with-styled-components)

[![Deploy with Vercel](https://vercel.com/button)](https://vercel.com/new/git/external?repository-url=https://github.com/vercel/next.js/tree/canary/examples/with-styled-components&project-name=with-styled-components&repository-name=with-styled-components)

## How to use

Execute [`create-next-app`](https://github.com/vercel/next.js/tree/canary/packages/create-next-app) with [npm](https://docs.npmjs.com/cli/init), [Yarn](https://yarnpkg.com/lang/en/docs/cli/create/), or [pnpm](https://pnpm.io) to bootstrap the example:

```bash
npx create-next-app --example with-styled-components with-styled-components-app
# or
yarn create next-app --example with-styled-components with-styled-components-app
# or
pnpm create next-app --example with-styled-components with-styled-components-app
```

Deploy it to the cloud with [Vercel](https://vercel.com/new?utm_source=github&utm_medium=readme&utm_campaign=next-example) ([Documentation](https://nextjs.org/docs/deployment)).

### Try it on CodeSandbox

[Open this example on CodeSandbox](https://codesandbox.io/s/github/vercel/next.js/tree/canary/examples/with-styled-components)

### Notes

When wrapping a [Link](https://nextjs.org/docs/api-reference/next/link) from `next/link` within a styled-component, the [as](https://styled-components.com/docs/api#as-polymorphic-prop) prop provided by `styled` will collide with the Link's `as` prop and cause styled-components to throw an `Invalid tag` error. To avoid this, you can either use the recommended [forwardedAs](https://styled-components.com/docs/api#forwardedas-prop) prop from styled-components or use a different named prop to pass to a `styled` Link.

<details>
<summary>Click to expand workaround example</summary>
<br />

**components/StyledLink.js**

```javascript
import Link from 'next/link'
import styled from 'styled-components'

const StyledLink = ({ as, children, className, href }) => (
  <Link href={href} as={as} passHref>
    <a className={className}>{children}</a>
  </Link>
)

export default styled(StyledLink)`
  color: #0075e0;
  text-decoration: none;
  transition: all 0.2s ease-in-out;

  &:hover {
    color: #40a9ff;
  }

  &:focus {
    color: #40a9ff;
    outline: none;
    border: 0;
  }
`
```

**pages/index.js**

```javascript
import StyledLink from '../components/StyledLink'

export default () => (
  <StyledLink href="/post/[pid]" forwardedAs="/post/abc">
    First post
  </StyledLink>
)
```

</details>



================================================
FILE: next-env.d.ts
================================================
/// <reference types="next" />
/// <reference types="next/image-types/global" />

// NOTE: This file should not be edited
// see https://nextjs.org/docs/pages/api-reference/config/typescript for more information.



================================================
FILE: next.config.js
================================================
/** @type {import('next').NextConfig} */

const nextConfig = {
  reactStrictMode: true,
  compiler: {
    styledComponents: true,
  },
  images: {
    domains: ["res.cloudinary.com", "firebasestorage.googleapis.com"],
  },
};

module.exports = nextConfig;



================================================
FILE: package.json
================================================
{
  "private": true,
  "scripts": {
    "dev": "next",
    "build": "next build",
    "start": "next start",
    "lint": "next lint"
  },
  "dependencies": {
    "@emotion/react": "^11.10.6",
    "@emotion/styled": "^11.10.6",
    "@headlessui/react": "^1.7.14",
    "@mui/material": "^5.11.14",
    "@progress/kendo-licensing": "^1.2.2",
    "@progress/kendo-react-excel-export": "^5.5.0",
    "ag-grid-community": "^28.0.2",
    "ag-grid-react": "^28.0.0",
    "bootstrap": "^5.2.3",
    "date-fns": "^2.30.0",
    "devextreme": "^22.1.3",
    "devextreme-react": "^22.1.3",
    "file-saver": "^2.0.5",
    "firebase": "^9.8.4",
    "formidable": "^3.5.2",
    "formik": "^2.2.9",
    "html-to-text": "^8.2.1",
    "jschardet": "^3.0.0",
    "jspdf": "^3.0.0",
    "jspdf-autotable": "^5.0.2",
    "mongoose": "^6.4.1",
    "mysql": "^2.18.1",
    "next": "latest",
    "nodemailer": "^6.8.0",
    "papaparse": "^5.4.0",
    "react": "^18.2.0",
    "react-autosuggest": "^10.1.0",
    "react-bootstrap": "^2.7.4",
    "react-csv": "^2.2.2",
    "react-data-export": "^0.6.0",
    "react-dom": "^18.2.0",
    "react-export-table-to-excel": "^1.0.3",
    "react-hook-form": "^7.37.0",
    "react-icons": "^4.4.0",
    "react-select": "^5.7.4",
    "react-to-print": "^2.14.7",
    "react-toastify": "^9.0.5",
    "recharts": "^2.15.1",
    "styled-components": "^5.3.5",
    "yup": "^0.32.11"
  },
  "devDependencies": {
    "@types/file-saver": "^2.0.5",
    "@types/node": "^18.0.0",
    "@types/papaparse": "^5.3.7",
    "@types/react": "^18.0.14",
    "@types/react-dom": "^18.0.5",
    "@types/styled-components": "^5.1.25",
    "autoprefixer": "^10.4.14",
    "eslint": "8.18.0",
    "eslint-config-next": "12.2.0",
    "postcss": "^8.4.23",
    "tailwindcss": "^3.3.2",
    "typescript": "^4.7.4"
  }
}



================================================
FILE: postcss.config.js
================================================
module.exports = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}



================================================
FILE: tailwind.config.js
================================================
/** @type {import('tailwindcss').Config} */
module.exports = {
  content: [
    "./app/**/*.{js,ts,jsx,tsx,mdx}",
    "./pages/**/*.{js,ts,jsx,tsx,mdx}",
    "./lib/**/*.{js,ts,jsx,tsx,mdx}",
 
    // Or if using `src` directory:
    "./src/**/*.{js,ts,jsx,tsx,mdx}",
  ],
  theme: {
    extend: {},
  },
  plugins: [],
}



================================================
FILE: tsconfig.json
================================================
{
  "compilerOptions": {
    "target": "es5",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": false,
    "forceConsistentCasingInFileNames": true,
    "noEmit": true,
    "incremental": true,
    "esModuleInterop": true,
    "module": "esnext",
    "resolveJsonModule": true,
    "moduleResolution": "node",
    "isolatedModules": true,
    "jsx": "preserve",
    "types": ["node", "file-saver"]
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx"],
  "exclude": ["node_modules"]
}


================================================
FILE: .eslintrc.json
================================================
{
  "extends": "next/core-web-vitals"
}



================================================
FILE: controllers/contexts/auth_context.ts
================================================
import { createContext } from "react";
import { AuthContextProps } from "../../models";

// contexto de sesion de la app
const AuthContext = createContext<AuthContextProps>({
  auth: null,
  login: () => null,
  logout: () => null,
});

export default AuthContext;



================================================
FILE: controllers/firebase/config.ts
================================================
import { initializeApp } from "firebase/app";
import { getStorage } from "firebase/storage";

const firebaseConfig = {
  apiKey: "AIzaSyBVE1_FgOYqG7JQRkZ2rFpXMR6WfqNqUlo",
  authDomain: "solicitudes-70af0.firebaseapp.com",
  projectId: "solicitudes-70af0",
  storageBucket: "solicitudes-70af0.appspot.com",
  messagingSenderId: "513108134731",
  appId: "1:513108134731:web:3aabdd8a5d4dcc54aab6ce",
  measurementId: "G-BYE06JTMPH"
};

// Inicializar Firebase
const firebaseApp = initializeApp(firebaseConfig);
const storage = getStorage(firebaseApp);

export { firebaseApp, storage };



================================================
FILE: controllers/firebase/uploadFile.ts
================================================
import { getStorage, ref, uploadBytesResumable, getDownloadURL } from "firebase/storage";
import  { firebaseApp } from "./config";

const uploadFile = async (file: File): Promise<string> => {
  if (file === null) return
  const storage = getStorage(firebaseApp);

  var today: Date = new Date();
  var date: string = today.getFullYear().toString() + (today.getMonth() + 1).toString() + today.getDate().toString();

  const storageRef = ref(storage, date + '/' + file.name);
  const uploadTaskSnapshot = await uploadBytesResumable(storageRef, file);
  return await getDownloadURL(uploadTaskSnapshot.ref)
}

export default uploadFile;


================================================
FILE: controllers/hooks/use_auth.ts
================================================
import { useContext } from "react";
import AuthContext from "../contexts/auth_context";
import { AuthContextProps } from "../../models";

// nos permite llamar a las variables del contexto
export const useAuth = (): AuthContextProps => useContext(AuthContext);



================================================
FILE: controllers/hooks/use_local_storage.ts
================================================
import { useState } from "react";

// administra datos del local storage
export const useLocalStorage = (key: string) => {
  // estado inicial de valor [key] ingresado
  const [storedValue, setStoredValue] = useState<any | null>(() => {
    if (typeof window !== "undefined") {
      try {
        const user = localStorage.getItem(key);
        return user ? JSON.parse(user) : null;
      } catch (error) {
        console.error(error);
        return null;
      }
    }
    return null;
  });

  // cambia el estado del valor [key] ingresado
  const setValue = (userToStore: any) => {
    if (typeof window !== "undefined") {
      try {
        setStoredValue(userToStore);
        localStorage.setItem(key, JSON.stringify(userToStore));
      } catch (error) {
        console.error(error);
      }
    }
  };

  // remueve el valor [key] ingresado
  const removeValue = () => {
    if (typeof window !== "undefined") {
      setStoredValue(null);
      localStorage.removeItem(key);
    }
  };

  return { storedValue, setValue, removeValue };
};



================================================
FILE: controllers/hooks/use_no_scroll.ts
================================================
export const useNoScroll = () => {
  const set = () => {
    if (typeof window !== "undefined") {
      document.addEventListener("wheel", function (event) {
        // @ts-ignore
        if (document.activeElement.type === "number" &&
          document.activeElement.classList.contains("noscroll")) {
          // @ts-ignore
          document.activeElement.blur();
        }
      });
    }
  };

  return { set }
}


================================================
FILE: controllers/hooks/use_window_size.ts
================================================
import { useState, useEffect } from "react";

export const sizes = {
  xs: 350,
  sm: 576,
  md: 768,
  lg: 992,
  xl: 1200,
  xxl: 1400,
};

export type Orientation = 'landscape' | 'portrait' | 'none';

type WindowData = {
  width: number;
  height: number;
  orientation: Orientation;
}

export function useWindowSize(): WindowData {
  const [windowSize, setWindowSize] = useState<WindowData>({
    width: 0,
    height: 0,
    orientation: 'none',
  });

  useEffect(() => {
    const handleResize = () => {
      setWindowSize({
        width: window.innerWidth,
        height: window.innerHeight,
        orientation: window.innerWidth > window.innerHeight ? 'landscape' : 'portrait',
      });
    }

    window.addEventListener("resize", handleResize);

    handleResize();

    // Remove the listener as soon as the component is unmounted
    return () => window.removeEventListener("resize", handleResize);
  }, []);

  return windowSize;
}


================================================
FILE: controllers/mongo/bodegas/create.ts
================================================
import { NextApiRequest, NextApiResponse } from "next";
import {
  AuditoryModel,
  BackupBodegaModel,
  BackupSolicitudesModel,
  BodegaModel,
} from "../../../database/schemas";
import { Bodega } from "../../../models";
import FormatedDate from "../../utils/formated_date";

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  const bodega = req.body as Bodega;
  const userName = req.headers.username as string;
  const count: number = await BackupBodegaModel.countDocuments();
  // fetch the posts
  const bodegapost = new BodegaModel({ ...bodega, number: count + 1 });

  await bodegapost.save();

  const auditory = new AuditoryModel({
    date: FormatedDate(),
    user: userName,
    action: "Creo una bodega: " + bodegapost.number,
  });
  await auditory.save();

  const backup = new BackupBodegaModel({ bodega: bodegapost._id });

  await backup.save();

  return res.status(200).json({
    message: "bodega Creada",
    success: true,
  });
}



================================================
FILE: controllers/mongo/bodegas/list.ts
================================================
import { NextApiRequest, NextApiResponse } from "next";
import { BodegaModel, HerramientaModel } from "../../../database/schemas";
import { Bodega, Herramienta } from "../../../models";


export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  // fetch the posts
  const bodegas = await BodegaModel.find({})

  return res.status(200).json({
    message: "todas las bodegass",
    data: bodegas as Array<Bodega>,
    success: true,
  });
}


================================================
FILE: controllers/mongo/bodegas/read.ts
================================================
import { NextApiRequest, NextApiResponse } from "next";
import { BodegaModel } from "../../../database/schemas";
import { Bodega } from "../../../models";

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  const id = req.query.id as string;

  // fetch the posts
  const bodega = await BodegaModel.findById(id);

  return res.status(200).json({
    message: "una bodega",
    data: bodega as Bodega,
    success: true,
  });
}



================================================
FILE: controllers/mongo/bodegas/update.ts
================================================
import { NextApiRequest, NextApiResponse } from "next";
import { Bodega } from "../../../models";
import FormatedDate from "../../utils/formated_date";
import { AuditoryModel, BodegaModel,  } from "../../../database/schemas";

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  const bodega = req.body as Bodega;
  const userName = req.headers.username as string;

  const newbodega = (): Bodega => {
    return bodega;
  };

  const resp = await BodegaModel.findOneAndUpdate(
    {
      _id: bodega.id,
    },
    newbodega()
  );

  const auditory = new AuditoryModel({
    date: FormatedDate(),
    user: userName,
    action: "Actualizo a la bodega:" + bodega.number,
  });
  await auditory.save();

  if (resp === null)
    return res.status(500).json({
      message: "bodega no encontrada",
      success: false,
    });

  return res.status(200).json({
    message: "bodega editada",
    success: true,
  });
}



================================================
FILE: controllers/mongo/calibracion/create.ts
================================================
import { NextApiRequest, NextApiResponse } from "next";
import {
  AuditoryModel,
  BackupCalibracionModel,
  CalibracionModel,
} from "../../../database/schemas";
import { Calibracion } from "../../../models";
import FormatedDate from "../../utils/formated_date";

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  const solicitud = req.body as Calibracion;
  const userName = req.headers.username as string;
  const count: number = await BackupCalibracionModel.countDocuments();
  // fetch the posts
  const solicitudpost = new CalibracionModel({ ...solicitud, number: count + 1 });

  await solicitudpost.save();

  const auditory = new AuditoryModel({
    date: FormatedDate(),
    user: userName,
    action: "Creo una solicitud de calibracion: " + solicitudpost.number,
  });
  await auditory.save();

  const backup = new BackupCalibracionModel({ solicitud: solicitudpost._id });

  await backup.save();

  return res.status(200).json({
    message: "solicitud Creada",
    success: true,
  });
}



================================================
FILE: controllers/mongo/calibracion/delete.ts
================================================
import { NextApiRequest, NextApiResponse } from "next";
import { AuditoryModel, CalibracionModel } from "../../../database/schemas";
import FormatedDate from "../../utils/formated_date";

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  const id = req.query.id as string;
  const userName = req.headers.username as string;
  const resp = await CalibracionModel.findByIdAndRemove(id);
  //{ acknowledged: true, deletedCount: 1 }

  const auditory = new AuditoryModel({
    date: FormatedDate(),
    user: userName,
    action: "Elimino una solicitud de calibracion: "+ resp.number,
  });
  await auditory.save();

  if (resp.deletedCount === 1)
    return res.status(200).json({
      message: "Eliminado!",
      success: true,
    });

  return res.status(500).json({
    message: "Error inesperado",
    success: false,
  });
}



================================================
FILE: controllers/mongo/calibracion/list.ts
================================================
import { NextApiRequest, NextApiResponse } from "next";
import { CalibracionModel } from "../../../database/schemas";
import { Calibracion } from "../../../models";

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  // fetch the posts
  const calibracion = await CalibracionModel.find({});

  if (req.query.dates !== undefined) {
    const dates: Array<string> = (req.query.dates as string).split("¡");
    const date1 = new Date(dates[0]);
    const date2 = new Date(dates[1]);
    date2.setDate(date2.getDate() + 1);

    const filtered = [];

    calibracion.forEach((soli: Calibracion) => {
      const soliDates = soli.fecha.replace(",", "").split(" ")[0].split("/");
      const soliDate = new Date(
        soliDates[2] +
          "-" +
          (soliDates[1].length < 2 ? "0" + soliDates[1] : soliDates[1]) +
          "-" +
          (soliDates[1].length < 2 ? "0" + soliDates[0] : soliDates[0])
      );
      if (
        date1.getTime() <= soliDate.getTime() &&
        soliDate.getTime() < date2.getTime()
      ) {
        filtered.push(soli);
      }
    });

    return res.status(200).json({
      message: "todas las solicitudes de calibracion",
      data: filtered as Array<Calibracion>,
      success: true,
    });
  } else {
    return res.status(200).json({
      message: "todas las solicitudes de calibracion",
      data: calibracion as Array<Calibracion>,
      success: true,
    });
  }
}



================================================
FILE: controllers/mongo/calibracion/read.ts
================================================
import { NextApiRequest, NextApiResponse } from "next";
import { CalibracionModel } from "../../../database/schemas";
import { Calibracion } from "../../../models";

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  const id = req.query.id as string;

  // fetch the posts
  const solicitud = await CalibracionModel.findById(id);

  return res.status(200).json({
    message: "una solicitud de calibracion",
    data: solicitud as Calibracion,
    success: true,
  });
}



================================================
FILE: controllers/mongo/calibracion/update.ts
================================================
import { NextApiRequest, NextApiResponse } from "next";
import { Calibracion } from "../../../models";
import FormatedDate from "../../utils/formated_date";
import { AuditoryModel, CalibracionModel,  } from "../../../database/schemas";

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  const solicitud = req.body as Calibracion;
  const userName = req.headers.username as string;

  const newsolicitud = (): Calibracion => {
    return solicitud;
  };

  const resp = await CalibracionModel.findOneAndUpdate(
    {
      _id: solicitud.id,
    },
    newsolicitud()
  );

  const auditory = new AuditoryModel({
    date: FormatedDate(),
    user: userName,
    action: "Actualizo a la solicitud de calibracion:" + solicitud.number,
  });
  await auditory.save();

  if (resp === null)
    return res.status(500).json({
      message: "solicitud no encontrada",
      success: false,
    });

  return res.status(200).json({
    message: "solicitud editada",
    success: true,
  });
}



================================================
FILE: controllers/mongo/herramientas/create.ts
================================================
import { NextApiRequest, NextApiResponse } from "next";
import { AuditoryModel, HerramientaModel,  } from "../../../database/schemas";
import { Herramienta } from "../../../models";
import FormatedDate from "../../utils/formated_date";

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  const herramienta = req.body as Herramienta;
  const userName = req.headers.username as string;
  // fetch the posts
  const herramientapost = new HerramientaModel({ ...herramienta });

  await herramientapost.save();

  const auditory = new AuditoryModel({
    date: FormatedDate(),
    user: userName,
    action: "Creo una herramienta: " + herramientapost.nombre,
  });
  await auditory.save();

  return res.status(200).json({
    message: "Herramienta Creada",
    success: true,
  });
}



================================================
FILE: controllers/mongo/herramientas/delete.ts
================================================
import { NextApiRequest, NextApiResponse } from "next";
import { AuditoryModel, HerramientaModel,  } from "../../../database/schemas";
import FormatedDate from "../../utils/formated_date";

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  const id = req.query.id as string;
  const userName = req.headers.username as string;
  const resp = await HerramientaModel.findByIdAndRemove(id);
  //{ acknowledged: true, deletedCount: 1 }

  const auditory = new AuditoryModel({
    date: FormatedDate(),
    user: userName,
    action: "Elimino una herramienta: "+ resp.nombre,
  });
  await auditory.save();

  if (resp.deletedCount === 1)
    return res.status(200).json({
      message: "Eliminado!",
      success: true,
    });

  return res.status(500).json({
    message: "Error inesperado",
    success: false,
  });
}



================================================
FILE: controllers/mongo/herramientas/list.ts
================================================
import { NextApiRequest, NextApiResponse } from "next";
import { HerramientaModel } from "../../../database/schemas";
import { Herramienta } from "../../../models";


export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  // fetch the posts
  const herramienta = await HerramientaModel.find({})

  return res.status(200).json({
    message: "todas las herramientas",
    data: herramienta as Array<Herramienta>,
    success: true,
  });
}


================================================
FILE: controllers/mongo/herramientas/read.ts
================================================
import { NextApiRequest, NextApiResponse } from "next";
import { HerramientaModel } from "../../../database/schemas";
import { Herramienta } from "../../../models";

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  const id = req.query.id as string;

  // fetch the posts
  const herramienta = await HerramientaModel.findById(id);

  return res.status(200).json({
    message: "un herramienta",
    data: herramienta as Herramienta,
    success: true,
  });
}



================================================
FILE: controllers/mongo/herramientas/update.ts
================================================
import { NextApiRequest, NextApiResponse } from "next";
import { Herramienta } from "../../../models";
import FormatedDate from "../../utils/formated_date";
import { AuditoryModel, HerramientaModel } from "../../../database/schemas";

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  const herramienta = req.body as Herramienta;
  const userName = req.headers.username as string;

  const newherramienta = (): Herramienta => {
    return herramienta;
  };

  const resp = await HerramientaModel.findOneAndUpdate(
    {
      _id: herramienta.id,
    },
    newherramienta()
  );

  const auditory = new AuditoryModel({
    date: FormatedDate(),
    user: userName,
    action: "Actualizo la herramienta:" + herramienta.nombre,
  });
  await auditory.save();

  if (resp === null)
    return res.status(500).json({
      message: "herramienta no encontrada",
      success: false,
    });

  return res.status(200).json({
    message: "herramienta editada",
    success: true,
  });
}



================================================
FILE: controllers/mongo/modelos/create.ts
================================================
import { NextApiRequest, NextApiResponse } from "next";
import {
  AuditoryModel,
  ModeloHerramientaModel,
} from "../../../database/schemas";
import { ModelosHerramienta } from "../../../models";
import FormatedDate from "../../utils/formated_date";

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  const Modelo = req.body as ModelosHerramienta;
  const userName = req.headers.username as string;
  // fetch the posts
  const Modelopost = new ModeloHerramientaModel({ ...Modelo });

  await Modelopost.save();

  const auditory = new AuditoryModel({
    date: FormatedDate(),
    user: userName,
    action: "Creo un Modelo: " + Modelopost.nombre,
  });
  await auditory.save();

  return res.status(200).json({
    message: "Modelo Creado",
    success: true,
  });
}



================================================
FILE: controllers/mongo/modelos/list.ts
================================================
import { NextApiRequest, NextApiResponse } from "next";
import { ModeloHerramientaModel } from "../../../database/schemas";
import { ModelosHerramienta } from "../../../models";

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  // fetch the posts
  const modelos = await ModeloHerramientaModel.find({});

  return res.status(200).json({
    message: "todos los modelos",
    data: modelos as Array<ModelosHerramienta>,
    success: true,
  });
}



================================================
FILE: controllers/mongo/modelos/read.ts
================================================
import { NextApiRequest, NextApiResponse } from "next";
import { ModeloHerramientaModel } from "../../../database/schemas";
import { ModelosHerramienta } from "../../../models";

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  const id = req.query.id as string;

  // fetch the posts
  const modelo = await ModeloHerramientaModel.findById(id);

  return res.status(200).json({
    message: "un modelo",
    data: modelo as ModelosHerramienta,
    success: true,
  });
}



================================================
FILE: controllers/mongo/modelos/update.ts
================================================
import { NextApiRequest, NextApiResponse } from "next";
import { ModelosHerramienta } from "../../../models";
import FormatedDate from "../../utils/formated_date";
import { AuditoryModel, ModeloHerramientaModel } from "../../../database/schemas";

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  const modelos = req.body as ModelosHerramienta;
  const userName = req.headers.username as string;

  const newmodelos = (): ModelosHerramienta => {
    return modelos;
  };

  const resp = await ModeloHerramientaModel.findOneAndUpdate(
    {
      _id: modelos.id,
    },
    newmodelos()
  );

  const auditory = new AuditoryModel({
    date: FormatedDate(),
    user: userName,
    action: "Actualizo el modelo:" + modelos.nombre,
  });
  await auditory.save();

  if (resp === null)
    return res.status(500).json({
      message: "Modelo no encontrada",
      success: false,
    });

  return res.status(200).json({
    message: "Modelo editado",
    success: true,
  });
}



================================================
FILE: controllers/mongo/solicitudes/create.ts
================================================
import { NextApiRequest, NextApiResponse } from "next";
import {
  AuditoryModel,
  BackupSolicitudesModel,
  SolicitudeModel,
} from "../../../database/schemas";
import { Solicitude } from "../../../models";
import FormatedDate from "../../utils/formated_date";

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  const solicitud = req.body as Solicitude;
  const userName = req.headers.username as string;
  const count: number = await BackupSolicitudesModel.countDocuments();
  // fetch the posts
  const solicitudpost = new SolicitudeModel({ ...solicitud, number: count + 1 });

  await solicitudpost.save();

  const auditory = new AuditoryModel({
    date: FormatedDate(),
    user: userName,
    action: "Creo una solicitud: " + solicitudpost.number,
  });
  await auditory.save();

  const backup = new BackupSolicitudesModel({ solicitud: solicitudpost._id });

  await backup.save();

  return res.status(200).json({
    message: "solicitud Creada",
    success: true,
  });
}



================================================
FILE: controllers/mongo/solicitudes/delete.ts
================================================
import { NextApiRequest, NextApiResponse } from "next";
import { AuditoryModel, SolicitudeModel } from "../../../database/schemas";
import FormatedDate from "../../utils/formated_date";

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  const id = req.query.id as string;
  const userName = req.headers.username as string;
  const resp = await SolicitudeModel.findByIdAndRemove(id);
  //{ acknowledged: true, deletedCount: 1 }

  const auditory = new AuditoryModel({
    date: FormatedDate(),
    user: userName,
    action: "Elimino una solicitud: "+ resp.number,
  });
  await auditory.save();

  if (resp.deletedCount === 1)
    return res.status(200).json({
      message: "Eliminado!",
      success: true,
    });

  return res.status(500).json({
    message: "Error inesperado",
    success: false,
  });
}



================================================
FILE: controllers/mongo/solicitudes/list.ts
================================================
import { NextApiRequest, NextApiResponse } from "next";
import { SolicitudeModel } from "../../../database/schemas";
import { Solicitude } from "../../../models";

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  // fetch the posts
  const herramientas = await SolicitudeModel.find({});

  if (req.query.dates !== undefined) {
    const dates: Array<string> = (req.query.dates as string).split("¡");
    const date1 = new Date(dates[0]);
    const date2 = new Date(dates[1]);
    date2.setDate(date2.getDate() + 1);

    const filtered = [];

    herramientas.forEach((soli: Solicitude) => {
      const soliDates = soli.fecha.replace(",", "").split(" ")[0].split("/");
      const soliDate = new Date(
        soliDates[2] +
          "-" +
          (soliDates[1].length < 2 ? "0" + soliDates[1] : soliDates[1]) +
          "-" +
          (soliDates[1].length < 2 ? "0" + soliDates[0] : soliDates[0])
      );
      if (
        date1.getTime() <= soliDate.getTime() &&
        soliDate.getTime() < date2.getTime()
      ) {
        filtered.push(soli);
      }
    });

    return res.status(200).json({
      message: "todas las herramientas",
      data: filtered as Array<Solicitude>,
      success: true,
    });
  } else {
    return res.status(200).json({
      message: "todas las herramientas",
      data: herramientas as Array<Solicitude>,
      success: true,
    });
  }
}



================================================
FILE: controllers/mongo/solicitudes/read.ts
================================================
import { NextApiRequest, NextApiResponse } from "next";
import { SolicitudeModel } from "../../../database/schemas";
import { Solicitude } from "../../../models";

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  const id = req.query.id as string;

  // fetch the posts
  const solicitud = await SolicitudeModel.findById(id);

  return res.status(200).json({
    message: "una solicitud",
    data: solicitud as Solicitude,
    success: true,
  });
}



================================================
FILE: controllers/mongo/solicitudes/update.ts
================================================
import { NextApiRequest, NextApiResponse } from "next";
import { Solicitude } from "../../../models";
import FormatedDate from "../../utils/formated_date";
import { AuditoryModel, SolicitudeModel } from "../../../database/schemas";

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  const solicitud = req.body as Solicitude;
  const userName = req.headers.username as string;

  const newsolicitud = (): Solicitude => {
    return solicitud;
  };

  const resp = await SolicitudeModel.findOneAndUpdate(
    {
      _id: solicitud.id,
    },
    newsolicitud()
  );

  const auditory = new AuditoryModel({
    date: FormatedDate(),
    user: userName,
    action: "Actualizo a la solicitud:" + solicitud.number,
  });
  await auditory.save();

  if (resp === null)
    return res.status(500).json({
      message: "solicitud no encontrada",
      success: false,
    });

  return res.status(200).json({
    message: "solicitud editada",
    success: true,
  });
}



================================================
FILE: controllers/mongo/ubicaciones/create.ts
================================================
import { NextApiRequest, NextApiResponse } from "next";
import {
  AuditoryModel,
  HerramientaModel,
  UbicacionesModel,
} from "../../../database/schemas";
import { Ubicaciones } from "../../../models";
import FormatedDate from "../../utils/formated_date";

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  const Ubicacion = req.body as Ubicaciones;
  const userName = req.headers.username as string;
  // fetch the posts
  const Ubicacionpost = new UbicacionesModel({ ...Ubicacion });

  await Ubicacionpost.save();

  const auditory = new AuditoryModel({
    date: FormatedDate(),
    user: userName,
    action: "Creo una Ubicacion: " + Ubicacionpost.nombre,
  });
  await auditory.save();

  return res.status(200).json({
    message: "Ubicacion Creada",
    success: true,
  });
}



================================================
FILE: controllers/mongo/ubicaciones/list.ts
================================================
import { NextApiRequest, NextApiResponse } from "next";
import { UbicacionesModel } from "../../../database/schemas";
import { Ubicaciones } from "../../../models";


export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  // fetch the posts
  const Ubicaciones = await UbicacionesModel.find({})

  return res.status(200).json({
    message: "todas las Ubicaciones",
    data: Ubicaciones as Array<Ubicaciones>,
    success: true,
  });
}


================================================
FILE: controllers/mongo/ubicaciones/read.ts
================================================
import { NextApiRequest, NextApiResponse } from "next";
import { UbicacionesModel } from "../../../database/schemas";
import { Ubicaciones } from "../../../models";

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  const id = req.query.id as string;

  // fetch the posts
  const Ubicaciones = await UbicacionesModel.findById(id);

  return res.status(200).json({
    message: "una Ubicaciones",
    data: Ubicaciones as Ubicaciones,
    success: true,
  });
}



================================================
FILE: controllers/mongo/ubicaciones/update.ts
================================================
import { NextApiRequest, NextApiResponse } from "next";
import { Ubicaciones } from "../../../models";
import FormatedDate from "../../utils/formated_date";
import { AuditoryModel, UbicacionesModel } from "../../../database/schemas";

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  const Ubicaciones = req.body as Ubicaciones;
  const userName = req.headers.username as string;

  const newUbicaciones = (): Ubicaciones => {
    return Ubicaciones;
  };

  const resp = await UbicacionesModel.findOneAndUpdate(
    {
      _id: Ubicaciones.id,
    },
    newUbicaciones()
  );

  const auditory = new AuditoryModel({
    date: FormatedDate(),
    user: userName,
    action: "Actualizo la Ubicacion:" + Ubicaciones.nombre,
  });
  await auditory.save();

  if (resp === null)
    return res.status(500).json({
      message: "Ubicacion no encontrada",
      success: false,
    });

  return res.status(200).json({
    message: "Ubicacion editada",
    success: true,
  });
}



================================================
FILE: controllers/mongo/user/create.ts
================================================
import { NextApiRequest, NextApiResponse } from "next";
import { UserModel, AuditoryModel } from "../../../database/schemas";
import { Usuario } from "../../../models";
import FormatedDate from "../../utils/formated_date";


export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  const user = req.body as Usuario;
  const userName = req.headers.username as string;
  // fetch the posts
  const soli = new UserModel(user)

  await soli.save()

  const auditory = new AuditoryModel({
    date: FormatedDate(),
    user: userName,
    action: "Creo un Usuario: "+soli.name,
  });
  await auditory.save();

  return res.status(200).json({
    message: "Usuario Creado",
    success: true,
  });
}


================================================
FILE: controllers/mongo/user/delete.ts
================================================
import { NextApiRequest, NextApiResponse } from "next";
import { AuditoryModel, UserModel } from "../../../database/schemas";
import FormatedDate from "../../utils/formated_date";

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  const id = req.query.id as string;
  const userName = req.headers.username as string;
  const resp = await UserModel.findByIdAndRemove(id);
  //{ acknowledged: true, deletedCount: 1 }

  const auditory = new AuditoryModel({
    date: FormatedDate(),
    user: userName,
    action: "Elimino un Usuario: "+ resp.name,
  });
  await auditory.save();

  if (resp.deletedCount === 1)
    return res.status(200).json({
      message: "Eliminado!",
      success: true,
    });

  return res.status(500).json({
    message: "Error inesperado",
    success: false,
  });
}



================================================
FILE: controllers/mongo/user/list.ts
================================================
import { NextApiRequest, NextApiResponse } from "next";
import { UserModel } from "../../../database/schemas";
import { Usuario } from "../../../models";


export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  // fetch the posts
  const solicitudes = await UserModel.find({}, { password: 0 })

  return res.status(200).json({
    message: "todas los usuarios",
    data: solicitudes as Array<Usuario>,
    success: true,
  });
}


================================================
FILE: controllers/mongo/user/read.ts
================================================
import { NextApiRequest, NextApiResponse } from "next";
import { UserModel } from "../../../database/schemas";
import { Usuario } from "../../../models";


export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  const id = req.query.id as string;

  // fetch the posts
  const solicitude = await UserModel.findById(id, { password: 0 })

  return res.status(200).json({
    message: "un usuario",
    data: solicitude as Usuario,
    success: true,
  });
}


================================================
FILE: controllers/mongo/user/update.ts
================================================
import { NextApiRequest, NextApiResponse } from "next";
import { Usuario } from "../../../models";
import FormatedDate from "../../utils/formated_date";
import { AuditoryModel, UserModel } from "../../../database/schemas";

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  const user = req.body as Usuario;
  const userName = req.headers.username as string;
  const resp = await UserModel.findOneAndUpdate(
    {
      _id: user.id,
    },
    user.contraseña !== ""
      ? user
      : {
          identificacion: user.identificacion,
          usuario: user.usuario,
          nombre: user.nombre,
          correo: user.correo,
          telefono: user.telefono,
          rol: user.rol,
          estado: user.estado,
        }
  );

  const auditory = new AuditoryModel({
    date: FormatedDate(),
    user: userName,
    action: "Actualizo al Usuario:" + user.nombre,
  });
  await auditory.save();

  if (resp === null)
    return res.status(500).json({
      message: "Usuario no encontrado",
      success: false,
    });

  return res.status(200).json({
    message: "Usuario editado",
    success: true,
  });
}



================================================
FILE: controllers/styles/global.ts
================================================
import { createGlobalStyle } from "styled-components";

// estilos globales
const GlobalStyle = createGlobalStyle`
  .actionButtonShow{
    cursor: pointer;
    height: 20px;
    background-color: #28a745;
  }
  .actionButtonEdit{
    cursor: pointer;
    height: 20px;
    background-color: #007bff;
  }
  .actionButtonEdit2{
    cursor: pointer;
    height: 20px;
  }
  .actionButtonDelete{
    cursor: pointer;
    height: 20px;
    background-color: #dc3545;
    color: white;
  }
  .actionButtonDownload{
    cursor: pointer;
    height: 20px;
    width: 25px;
    background-color: #FFA500;
    color: white;
  }
  .dx-treelist-headers .column-soli {
    color: rgb(93, 207, 201);
    font-weight: bold;
  }
  .dx-treelist-headers .column-conta {
    color: rgb(192, 93, 207);
    font-weight: bold;
  }
  .dx-treelist-headers .column-teso {
    color: rgb(209, 122, 36);
    font-weight: bold;
  }
  .dx-treelist-headers .column-finan {
    color: rgb(110, 199, 88);
    font-weight: bold;
  }
  .dx-treelist-headers .bold {
    font-weight: bold;
    font-size: 11px;
  }
`;

export default GlobalStyle;



================================================
FILE: controllers/styles/theme.ts
================================================
// datos del tema de la app
const theme = {
  colors: {
    red: "#8c130f",
    softRed: "rgba(25, 26, 25)",
    grey: "#495057",
    blue: "blue"
  },
};

export default theme;



================================================
FILE: controllers/utils/check_permissions.ts
================================================
import { Usuario, UserRole } from "../../models"


const CheckPermissions = (auth: Usuario, permissions: Array<UserRole>): boolean => {
  if(!auth) return false
  if(permissions.includes(auth.rol)) return true
  return false
}

const CheckFinished= (auth: Usuario, permissions: Array<UserRole>, state: string, spected: string) => CheckPermissions(auth, permissions) && state === spected

export { CheckPermissions , CheckFinished }


================================================
FILE: controllers/utils/constants.ts
================================================
export const Elaborando = "Elaborando" 

export const Aprobado = "Aprobado"

export const Procesando = "Procesando"

export const Pendiente = "Pendiente"

export const Cerrado = "Cerrado"

export const Abierto = "Abierto"

export const Rechazado = "Rechazado"

export const Terminado = "Terminado"

export const Observacion = "Observacion"



================================================
FILE: controllers/utils/formated_date.ts
================================================
const FormatedDate = (): string => new Date().toLocaleString('es-ES', {
    timeZone: 'America/Guayaquil'
  });
export default FormatedDate


================================================
FILE: controllers/utils/http_client.ts
================================================
import { ResponseData } from "../../models";

type Method = 'GET' | 'POST' | 'PUT' | 'DELETE'

const HttpClient = async (path: string, method: Method, userName: string, role: number, body?: any): Promise<ResponseData> => {
  try {
    const request: Response = await fetch(path, {
      method,
      body: JSON.stringify(body),
      headers: {
        "Content-Type": "application/json",
        "userName": userName,
        "role": role.toString(),
      },
    });
    const response: ResponseData = await request.json();
    return response;
  } catch (error) {
    return {
      message: "Error en la red",
      success: false,
    };
  }
};

export default HttpClient;



================================================
FILE: controllers/utils/upload_solicitude_images.ts
================================================
import { CloudImage, Herramienta } from "../../models";
import uploadFile from "../firebase/uploadFile";


const checkFile = (file: File | CloudImage): boolean => {
  return (file as CloudImage)?.secure_url !== undefined ? true : false
}

export const UploadSolicitudeImages = async (
    factures: Array<Herramienta>
  ): Promise<Array<Herramienta>> => {
    for (let i = 0; i < factures.length; i++) {
      if(factures[i].file !== undefined) {
        if (!checkFile(factures[i].file)) {
          const data = await uploadFile(factures[i].file as File)
          factures[i].file = {
            secure_url: data,
          };
        }
      }
    }
    return factures;
  };


================================================
FILE: database/schemas.ts
================================================
import mongoose, { mongo, Schema } from "mongoose";
import {
  Auditory,
  Backup,
  Bodega,
  Calibracion,
  Herramienta,
  ModelosHerramienta,
  Solicitude,
  Ubicaciones,
  Usuario,
} from "../models";

const UserSchema = new mongoose.Schema<Usuario>(
  {
    number: { type: Number },
    usuario: { type: String, unique: true },
    contraseña: { type: String },
    nombre: { type: String },
    correo: { type: String },
    identificacion: { type: String },
    telefono: { type: String },
    rol: { type: Number },
    estado: { type: String },
  },
  { timestamps: true }
);

// Duplicate the ID field.
UserSchema.virtual("id").get(function () {
  return this._id.toHexString();
});

// Ensure virtual fields are serialised.
UserSchema.set("toJSON", {
  virtuals: true,
});

export const UserModel =
  mongoose.models.Users || mongoose.model("Users", UserSchema);

const UbicacionesSchema = new mongoose.Schema<Ubicaciones>(
  {
    nombre: { type: String },
  },
  { timestamps: true }
);

// Duplicate the ID field.
UbicacionesSchema.virtual("id").get(function () {
  return this._id.toHexString();
});

// Ensure virtual fields are serialised.
UbicacionesSchema.set("toJSON", {
  virtuals: true,
});

export const UbicacionesModel =
  mongoose.models.Ubicaciones ||
  mongoose.model("Ubicaciones", UbicacionesSchema);

const ModeloHerramientaSchema = new mongoose.Schema<ModelosHerramienta>(
  {
    nombre: { type: String },
  },
  { timestamps: true }
);

// Duplicate the ID field.
ModeloHerramientaSchema.virtual("id").get(function () {
  return this._id.toHexString();
});

// Ensure virtual fields are serialised.
ModeloHerramientaSchema.set("toJSON", {
  virtuals: true,
});

export const ModeloHerramientaModel =
  mongoose.models.ModeloHerramienta ||
  mongoose.model("ModeloHerramienta", ModeloHerramientaSchema);

const HerramientaSchema = new mongoose.Schema<Herramienta>(
  {
    nombre: { type: String },
    codigo: { type: String },
    descripcion: { type: String },
    serie: { type: String },
    modelo: { type: String },
    marca: { type: String },
    NParte: { type: String },
    ubicacion: { type: String },
    estado: { type: String },
    imagen: { type: String },
    tipo: { type: String },
    cantidad: { type: Number },
    observacion: { type: String },
    calibracion: { type: String },
  },
  { timestamps: true }
);

// Duplicate the ID field.
HerramientaSchema.virtual("id").get(function () {
  return this._id.toHexString();
});

// Ensure virtual fields are serialised.
HerramientaSchema.set("toJSON", {
  virtuals: true,
});

export const HerramientaModel =
  mongoose.models.Herramienta ||
  mongoose.model("Herramienta", HerramientaSchema);

const BodegaSchema = new mongoose.Schema<Bodega>(
  {
    number: { type: Number },
    fechaDeCreacion: { type: String },
    bodegueroAsignado: { type: String },
    herramientas: { type: [HerramientaSchema] },
    creador: { type: String },
    nombreBodega: { type: String },  
  },
  { timestamps: true }
);

// Duplicate the ID field.
BodegaSchema.virtual("id").get(function () {
  return this._id.toHexString();
});

// Ensure virtual fields are serialised.
BodegaSchema.set("toJSON", {
  virtuals: true,
});

export const BodegaModel =
  mongoose.models.Bodegas || mongoose.model("Bodegas", BodegaSchema);

const SolicitudeSchema = new mongoose.Schema<Solicitude>(
  {
    number: { type: Number },
    fecha: { type: String },
    solicitante: { type: String },
    herramientas: { type: [HerramientaSchema] },
    receptor: { type: String },
    estado: { type: String },
  },
  { timestamps: true }
);

// Duplicate the ID field.
SolicitudeSchema.virtual("id").get(function () {
  return this._id.toHexString();
});

// Ensure virtual fields are serialised.
SolicitudeSchema.set("toJSON", {
  virtuals: true,
});

export const SolicitudeModel =
  mongoose.models.Solicitudes ||
  mongoose.model("Solicitudes", SolicitudeSchema);

const CalibracionSchema = new mongoose.Schema<Calibracion>(
  {
    number: { type: Number },
    fecha: { type: String },
    solicitante: { type: String },
    herramientas: { type: [HerramientaSchema] },
    estado: { type: String },
  },
  { timestamps: true }
);

// Duplicate the ID field.
CalibracionSchema.virtual("id").get(function () {
  return this._id.toHexString();
});

// Ensure virtual fields are serialised.
CalibracionSchema.set("toJSON", {
  virtuals: true,
});

export const CalibracionModel =
  mongoose.models.Calibracion ||
  mongoose.model("Calibracion", CalibracionSchema);

  const BackupBodegaSchema = new mongoose.Schema<Backup>(
    {
      solicitude: {
        type: mongoose.Schema.Types.ObjectId,
        ref: "Bodegas",
      },
    },
    { timestamps: true }
  );
  
  BackupBodegaSchema.virtual("id").get(function () {
    return this._id.toHexString();
  });
  
  BackupBodegaSchema.set("toJSON", {
    virtuals: true,
  });
  
  export const BackupBodegaModel =
    mongoose.models.BackupsBodega ||
    mongoose.model("BackupsBodega", BackupBodegaSchema);
  

const BackupSolicitudesSchema = new mongoose.Schema<Backup>(
  {
    solicitude: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "Solicitudes",
    },
  },
  { timestamps: true }
);

BackupSolicitudesSchema.virtual("id").get(function () {
  return this._id.toHexString();
});

BackupSolicitudesSchema.set("toJSON", {
  virtuals: true,
});

export const BackupSolicitudesModel =
  mongoose.models.BackupsSolicitudes ||
  mongoose.model("BackupsSolicitudes", BackupSolicitudesSchema);

const BackupCalibracionSchema = new mongoose.Schema<Backup>(
    {
      solicitude: {
        type: mongoose.Schema.Types.ObjectId,
        ref: "Calibracion",
      },
    },
    { timestamps: true }
  );
  
  BackupCalibracionSchema.virtual("id").get(function () {
    return this._id.toHexString();
  });
  
  BackupCalibracionSchema.set("toJSON", {
    virtuals: true,
  });
  
  export const BackupCalibracionModel =
    mongoose.models.BackupsCalibracion ||
    mongoose.model("BackupsCalibracion", BackupCalibracionSchema);

const AuditorySchema = new mongoose.Schema<Auditory>(
  {
    date: { type: String },
    user: { type: String },
    action: { type: String },
  },
  { timestamps: true }
);

// Duplicate the ID field.
AuditorySchema.virtual("id").get(function () {
  return this._id.toHexString();
});

// Ensure virtual fields are serialised.
AuditorySchema.set("toJSON", {
  virtuals: true,
});

export const AuditoryModel =
  mongoose.models.Auditory || mongoose.model("Auditory", AuditorySchema);



================================================
FILE: database/connect/mongo.ts
================================================
import mongoose from 'mongoose'

const MONGODB_URI = process.env.MONGODB_URI;

if (!MONGODB_URI) {
  throw new Error(
    'Please define the MONGODB_URI environment variable inside .env.local'
  )
}

let cached = global.mongoose

if (!cached) {
  cached = global.mongoose = { conn: null, promise: null }
}

async function dbConnect() {
  if (cached.conn) {
    return cached.conn
  }

  if (!cached.promise) {
    const opts = {
      // useNewUrlParser: true,
      // useUnifiedTopology: true,
      // bufferCommands: false,
      // bufferMaxEntries: 0,
      // useFindAndModify: true,
      // useCreateIndex: true
    }

    cached.promise = mongoose.connect(MONGODB_URI, opts).then(mongoose => {
      return mongoose
    })
  }
  cached.conn = await cached.promise
  return cached.conn
}

export default dbConnect



================================================
FILE: models/index.d.ts
================================================
import { FormikProps, FormikErrors, FormikTouched } from "formik";

//tipos de datos para la app
export type AuthContextProps = {
  auth: Usuario | null;
  login: (userData: Usuario) => void;
  logout: () => void;
};

//Datos de respuesta
export type ResponseData = {
  message?: string;
  data?: any;
  success: boolean;
};

//Datos del login
export type LoginData = {
  usuario: string;
  contraseña: string;
};

//Roles del sistema
export type UserRole =
  | 0 //Administrador
  | 1 //Bodeguero
  | 2; //Cliente

// Modelo para los usuarios
export type Usuario = {
  id?: string;
  number: number;
  identificacion: string;
  usuario: string;
  contraseña: string;
  nombre: string;
  correo: string;
  telefono: string;
  rol: UserRole;
  estado: string;
};

export type CloudImage = {
  secure_url: string;
};

export type Ubicaciones = {
  id?: string;
  nombre: string;
};

export type ModelosHerramienta = {
  id?: string;
  nombre: string;
};

// Modelo para los productos
export type Herramienta = {
  id?: string;
  nombre: string;
  codigo: string;
  descripcion: string;
  serie: string;
  modelo: string;
  marca: string;
  NParte: string;
  ubicacion: string;
  estado: string;
  imagen: string;
  tipo: string;
  cantidad: number;
  observacion: string;
  calibracion: string;
  file?: File | CloudImage;
};

// Modelo para las ventas
export type Bodega = {
  id?: string;
  number: number;
  herramientas: Array<Herramienta>;
  fechaDeCreacion: string;
  creador: string;
  bodegueroAsignado: string;
  nombreBodega: string;
};

// Modelo para las ventas
export type Solicitude = {
  id?: string;
  number: number;
  herramientas: Array<Herramienta>;
  fecha: string;
  solicitante: string;
  receptor: string;
  estado: string;
};

export type Calibracion = {
  id?: string;
  number: number;
  herramientas: Array<Herramienta>;
  fecha: string;
  solicitante: string;
  estado: string;
};

//backups
export type Backup = {
  id?: string;
  solicitude: any | Solicitude;
  bodega: any | Bodega;
  usuario: any | Usuario;
  calibracion: any | Calibracion;
};

//Auditoria del sistema
export type Auditory = {
  id?: string;
  date: string;
  user: string;
  action: string;
};

export interface ModalProps<T> {
  visible: boolean;
  close: () => void;
  onDone?: (data?: T) => void | Promise<void>;
}

export interface FormikComponentProps<T = Element> extends FormikProps<T> {
  formik: {
    values: T;
    handleChange: {
      (e: ChangeEvent<any>): void;
      <T_1 = string | ChangeEvent<T>>(field: T_1): T_1 extends ChangeEvent<T>
        ? void
        : (e: string | ChangeEvent<T>) => void;
    };
    touched: FormikTouched<T>;
    errors: FormikErrors<T>;
    setFieldValue: (
      field: string,
      value: T,
      shouldValidate?: boolean
    ) => Promise<void> | Promise<FormikErrors<T>>;
    setFieldError: (field: string, value: string) => void;
  };
}



================================================
FILE: pages/_app.tsx
================================================
import { ThemeProvider } from "styled-components";
import "devextreme/dist/css/dx.light.css";
import "react-toastify/dist/ReactToastify.css";
import GlobalStyle from "../controllers/styles/global";
import theme from "../controllers/styles/theme";
import { useLocalStorage } from "../controllers/hooks/use_local_storage";
import { useEffect, useMemo, useState } from "react";
import AuthContext from "../controllers/contexts/auth_context";
import { AuthContextProps, Usuario,  } from "../models";
import SessionLayout from "./layouts/session_layout";
import { useNoScroll } from "../controllers/hooks/use_no_scroll";
import "../styles/global.css";
import ToastContainer from "./components/toastify";

// configuracion general de la app
export default function App({ Component, pageProps }) {
  // hook para obtener los datos de usuario en el local storage
  const { storedValue, setValue, removeValue } = useLocalStorage("userData");
  // estado del usuario en la app
  const [auth, setAuth] = useState(null);

  useNoScroll().set();

  // revisa y configura si hay un usuario guardado
  useEffect(() => {
    (() => {
      storedValue &&
        setAuth({ ...storedValue, rol: parseInt(storedValue.rol) });
    })();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  // permite iniciar sesion
  const login = (userData: Usuario) => {
    setValue(userData);
    setAuth(userData);
  };

  // permite cerrar sesion
  const logout = () => {
    if (auth) {
      setAuth(null);
      removeValue();
    }
  };

  // guarda y actualiza las variables del contexto
  const authData = useMemo<AuthContextProps>(
    () => ({ auth, login, logout }),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [auth]
  );

  return (
    // provee de variables de context
    <AuthContext.Provider value={authData}>
      <GlobalStyle />
      <ThemeProvider theme={theme}>
      {/* muestra alertas */}
      <ToastContainer />
      <SessionLayout>
        {/* ruta actual renderizada */}
        <Component {...pageProps} />
      </SessionLayout>
      </ThemeProvider>
    </AuthContext.Provider>
  );
}



================================================
FILE: pages/_document.tsx
================================================
import Document, {
  DocumentContext,
  Head,
  Html,
  Main,
  NextScript,
} from "next/document";
import { ServerStyleSheet } from "styled-components";

// rehidrata los estilos para bootstrap
export default class MyDocument extends Document {
  static async getInitialProps(ctx: DocumentContext) {
    const sheet = new ServerStyleSheet();
    const originalRenderPage = ctx.renderPage;

    try {
      ctx.renderPage = () =>
        originalRenderPage({
          enhanceApp: (App) => (props) =>
            sheet.collectStyles(<App {...props} />),
        });

      const initialProps = await Document.getInitialProps(ctx);
      return {
        ...initialProps,
        styles: [initialProps.styles, sheet.getStyleElement()],
      };
    } finally {
      sheet.seal();
    }
  }

  render() {
    return (
      <Html lang="es">
        <Head />

        <body>
          <Main />
          <NextScript />
        </body>
      </Html>
    );
  }
}



================================================
FILE: pages/auditory.tsx
================================================
import RoleLayout from "./layouts/role_layout";
import { useEffect, useState } from "react";
import LoadingContainer from "./components/loading_container";
import { useAuth } from "../controllers/hooks/use_auth";
import HttpClient from "../controllers/utils/http_client";
import { Auditory } from "../models";
import Sidebar from "./components/sidebar";
import TreeTable, { ColumnData } from "./components/tree_table";

const AuditoryPage = () => {
  const { auth } = useAuth();
  const [loading, setLoading] = useState<boolean>(true);
  const [tableData, setTableData] = useState<Array<Auditory>>([]);

  const loadData = async () => {
    setLoading(true);
    const response = await HttpClient(
      "/api/auditory",
      "GET",
      auth.usuario,
      auth.rol
    );
    const auditories: Array<Auditory> = response.data ?? [];
    setTableData(auditories);
    setLoading(false);
  };

  const columns: ColumnData[] = [
    {
      dataField: "date",
      caption: "Fecha y Hora",
      alignment: "center",
    },
    {
      dataField: "user",
      caption: "Usuario",
      alignment: "center",
    },
    {
      dataField: "action",
      caption: "Acción realizada",
      alignment: "center",
    },
  ];

  useEffect(() => {
    loadData();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  return (
    <RoleLayout permissions={[0]}>
      <title>Auditoría</title>
      <div className="flex h-full">
        <div className="md:w-1/6 max-w-none">
          <Sidebar />
        </div>
        <div className="w-12/12 md:w-5/6 flex items-center justify-center">
          <div className="w-11/12 bg-white my-14">
            <div className="grid grid-cols-1 md:grid-cols-1 gap-4 m-2">
              <LoadingContainer visible={loading} miniVersion>
                <TreeTable
                  keyExpr="id"
                  dataSource={tableData}
                  columns={columns}
                  searchPanel={true}
                  style={{ marginBottom: "40px" }}
                  colors={{
                    headerBackground: "#F8F9F9",
                    headerColor: "#CD5C5C",
                  }}
                />
              </LoadingContainer>
            </div>
          </div>
        </div>
      </div>
    </RoleLayout>
  );
};

export default AuditoryPage;



================================================
FILE: pages/configuration.tsx
================================================
import React from "react";
import UsersPanel from "./layouts/config/users";
import RoleLayout from "./layouts/role_layout";
import Sidebar from "./components/sidebar";
import TabContainer, { TabPanel } from "./components/tab_container";
import UbicacionesPanel from "./layouts/config/ubicaciones";
import ModelosPanel from "./layouts/config/modelos";

const Configuration = () => {
  const tabPanels: Array<TabPanel> = [
    {
      name: "Usuarios",
      content: <UsersPanel />,
    },
    {
      name: "Ubicaciones",
      content: <UbicacionesPanel />,
    },
    {
      name: "Modelos",
      content: <ModelosPanel />,
    },
  ];

  return (
    <RoleLayout permissions={[0]}>
      <title>Configuracion del sistema</title>

      <div className="flex h-full">
        <div className="md:w-1/6 max-w-none">
          <Sidebar />
        </div>
        <div className="w-12/12 md:w-5/6 h-screen flex items-center justify-center bg-blue-100">
          <div className="w-11/12 bg-white my-14">
            <div className="grid grid-cols-1 md:grid-cols-1 gap-4 m-2">
              <TabContainer
                tabPanels={tabPanels}
                style={{ padding: "40px 0" }}
              />
            </div>
          </div>
        </div>
      </div>
    </RoleLayout>
  );
};
export default Configuration;



================================================
FILE: pages/index.tsx
================================================
/* eslint-disable react/no-unescaped-entities */
/* eslint-disable @next/next/no-img-element */

import { useState, useEffect } from "react";
import { useAuth } from "../controllers/hooks/use_auth";
import HttpClient from "../controllers/utils/http_client";
import { Herramienta } from "../models";
import Sidebar from "./components/sidebar";
import { BarChart, Bar, XAxis, YAxis, Tooltip, Legend, ResponsiveContainer } from "recharts";
import jsPDF from "jspdf";
import autoTable from "jspdf-autotable";

export default function Home() {
  const { auth } = useAuth();
  const [tableData, setTableData] = useState<Array<Herramienta>>([]);
  const [loading, setLoading] = useState<boolean>(true);

  const loadData = async () => {
    setLoading(true);
    var response = await HttpClient("/api/herramientas", "GET", auth.usuario, auth.rol);
    const herramientas: Array<Herramienta> = response.data ?? [];
    setTableData(herramientas);
    setLoading(false);
  };

  useEffect(() => {
    loadData();
  // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  // Cálculo de métricas
  const totalHerramientas = tableData.length;
  const disponibles = tableData.filter(h => h.estado === "Disponible");
  const enUso = tableData.filter(h => h.estado === "En uso");
  const calibradas = tableData.filter(h => h.calibracion === "Calibrada");
  const noCalibradas = tableData.filter(h => h.calibracion === "No calibrada");

  // Datos para el gráfico
  const data = [
    { name: "Total", value: totalHerramientas },
    { name: "Disponibles", value: disponibles.length },
    { name: "En uso", value: enUso.length },
    { name: "Calibradas", value: calibradas.length },
    { name: "No calibradas", value: noCalibradas.length }
  ];

  // Función para generar un reporte en PDF con detalles
  const generatePDF = (title: string, herramientas: Herramienta[]) => {
    const doc = new jsPDF();
    doc.setFontSize(16);
    doc.text(title, 14, 10);

    if (herramientas.length === 0) {
      doc.text("No hay herramientas registradas en esta categoría.", 14, 20);
    } else {
      const headers = [["Nombre", "Código", "Marca", "Serie", "Ubicación", "Cantidad"]];
      const data = herramientas.map(h => [h.nombre, h.codigo, h.marca, h.serie, h.ubicacion, h.cantidad]);

      autoTable(doc, {
        head: headers,
        body: data,
        startY: 20,
        styles: { fontSize: 10 },
        headStyles: { fillColor: [0, 122, 204] },
      });
    }

    doc.save(`${title}.pdf`);
  };

  return (
    <>
      <div className="flex h-screen">
        <div className="md:w-1/6 max-w-none">
          <Sidebar />
        </div>
        <div className="w-12/12 md:w-5/6 bg-blue-100">
          <div className="flex-1 p-6">
            <div className="bg-white w-full rounded-xl shadow-2xl p-8 mb-8">
              <div className="flex items-center mb-8">
                <p className="text-3xl text-center text-blue-800 font-bold w-full">
                  <strong>Sistema de Gestión de Herramientas</strong>
                </p>
                <hr className="mt-4 mb-6 border-t-2 border-blue-300" />
              </div>

              {/* Métricas */}
              <div className="grid grid-cols-2 md:grid-cols-5 gap-4 mb-8">
                <div className="bg-blue-200 p-4 rounded-lg text-center">
                  <p className="text-xl font-bold">{totalHerramientas}</p>
                  <p className="text-sm">Total Herramientas</p>
                </div>
                <div className="bg-green-200 p-4 rounded-lg text-center">
                  <p className="text-xl font-bold">{disponibles.length}</p>
                  <p className="text-sm">Disponibles</p>
                </div>
                <div className="bg-red-200 p-4 rounded-lg text-center">
                  <p className="text-xl font-bold">{enUso.length}</p>
                  <p className="text-sm">En Uso</p>
                </div>
                <div className="bg-yellow-200 p-4 rounded-lg text-center">
                  <p className="text-xl font-bold">{calibradas.length}</p>
                  <p className="text-sm">Calibradas</p>
                </div>
                <div className="bg-gray-300 p-4 rounded-lg text-center">
                  <p className="text-xl font-bold">{noCalibradas.length}</p>
                  <p className="text-sm">No Calibradas</p>
                </div>
              </div>

              {/* Gráfico */}
              <div className="bg-white p-6 rounded-lg shadow">
                <h2 className="text-center text-xl font-bold mb-4">Estado de las Herramientas</h2>
                <ResponsiveContainer width="100%" height={300}>
                  <BarChart data={data} margin={{ top: 20, right: 30, left: 20, bottom: 5 }}>
                    <XAxis dataKey="name" />
                    <YAxis />
                    <Tooltip />
                    <Legend />
                    <Bar dataKey="value" fill="#8884d8" />
                  </BarChart>
                </ResponsiveContainer>
              </div>

              {/* Botones para Exportar PDF */}
              <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4 mt-6">
                <button
                  onClick={() => generatePDF("Reporte General de Herramientas", tableData)}
                  className="bg-red-500 text-white px-4 py-2 rounded-lg hover:bg-red-600"
                >
                  Exportar Reporte General
                </button>
                <button
                  onClick={() => generatePDF("Reporte de Herramientas Disponibles", disponibles)}
                  className="bg-green-500 text-white px-4 py-2 rounded-lg hover:bg-green-600"
                >
                  Exportar Disponibles
                </button>
                <button
                  onClick={() => generatePDF("Reporte de Herramientas en Uso", enUso)}
                  className="bg-yellow-500 text-white px-4 py-2 rounded-lg hover:bg-yellow-600"
                >
                  Exportar En Uso
                </button>
                <button
                  onClick={() => generatePDF("Reporte de Herramientas Calibradas", calibradas)}
                  className="bg-blue-500 text-white px-4 py-2 rounded-lg hover:bg-blue-600"
                >
                  Exportar Calibradas
                </button>
                <button
                  onClick={() => generatePDF("Reporte de Herramientas No Calibradas", noCalibradas)}
                  className="bg-gray-500 text-white px-4 py-2 rounded-lg hover:bg-gray-600"
                >
                  Exportar No Calibradas
                </button>
              </div>

            </div>
          </div>
        </div>
      </div>
    </>
  );
}



================================================
FILE: pages/login.tsx
================================================
/* eslint-disable @next/next/no-img-element */
import { useState } from "react";
import { useFormik } from "formik";
import { toast } from "react-toastify";
import { useAuth } from "../controllers/hooks/use_auth";
import HttpClient from "../controllers/utils/http_client";
import { LoginData } from "../models";
import LoadingContainer from "./components/loading_container";
import Router from "next/router";

const currentYear = new Date().getFullYear();
// login de la app
const LoginPage = () => {
  const [loading, setLoading] = useState<boolean>(false);
  // llama la funcion para iniciar sesion
  const { login } = useAuth();

  // valores del formulario
  const [initialValues, _setInitialValues] = useState<LoginData>({
    usuario: "",
    contraseña: "",
  });

  // envia los datos del formulario
  const onSubmit = async (formData: LoginData) => {
    setLoading(true);
    const response = await HttpClient("/api/login", "POST", "", -1, formData);
    if (response.success) {
      const data = response.data;
      login(data);
      console.log(formData);
      Router.push({ pathname: "/" });
    } else {
      toast.warning(response.message);
    }
    setLoading(false);
  };

  // maneja los datos y comportamiento del formulario
  const formik = useFormik({
    enableReinitialize: true,
    validateOnMount: true,
    validateOnBlur: true,
    validateOnChange: true,
    initialValues,
    onSubmit,
  });

  const handleRegister = () => {
    setLoading(true);

    Router.push({ pathname: "/registro" });
  };

  const handleRecuperarClave = () => {
    setLoading(true);

    Router.push({ pathname: "/recuperar" });
  };

  return (
    <>
      <title>Inicio de sesión</title>
      <section className="min-h-screen w-full flex items-center justify-center bg-gradient-to-r from-blue-400 via-blue-500 to-blue-600">
        <div className="flex flex-col items-center justify-center rounded-3xl shadow-lg bg-white w-full max-w-md p-8">
          <h2 className="text-center text-3xl font-extrabold text-blue-800 mb-6">
            Sistema de herramientas
          </h2>

          <LoadingContainer visible={loading} miniVersion>
            <form onSubmit={formik.handleSubmit} className="w-full">
              <div className="mb-6">
                <label
                  htmlFor="userName"
                  className="block text-sm font-medium text-gray-700"
                >
                  Nombre de Usuario
                </label>
                <input
                  type="text"
                  name="usuario"
                  value={formik.values.usuario}
                  onChange={formik.handleChange}
                  placeholder="Ingrese su usuario"
                  className="mt-1 block w-full h-12 px-4 py-2 border border-gray-300 rounded-lg shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
                />
              </div>
              <div className="mb-6">
                <label
                  htmlFor="password"
                  className="block text-sm font-medium text-gray-700"
                >
                  Contraseña
                </label>
                <input
                  type="password"
                  name="contraseña"
                  value={formik.values.contraseña}
                  onChange={formik.handleChange}
                  placeholder="Ingrese su contraseña"
                  className="mt-1 block w-full h-12 px-4 py-2 border border-gray-300 rounded-lg shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
                />
              </div>

              <button
                type="submit"
                className="w-full py-3 px-4 bg-blue-500 hover:bg-blue-600 text-white rounded-lg font-semibold transition-colors"
              >
                Iniciar Sesión
              </button>
            </form>
            <button
              onClick={handleRegister}
              className="w-full mt-3 py-3 px-4 bg-green-500 hover:bg-green-600 text-white rounded-lg font-semibold transition-colors"
            >
              Registrarse
            </button>
            <button
              onClick={handleRecuperarClave}
              className="w-full mt-3 py-3 px-4 bg-gray-500 hover:bg-gray-600 text-white rounded-lg font-semibold transition-colors"
            >
              Recuperar contraseña
            </button>
          </LoadingContainer>
        </div>
      </section>
    </>
  );
};

export default LoginPage;



================================================
FILE: pages/recuperar.tsx
================================================
/* eslint-disable @next/next/no-img-element */
import { useEffect, useState } from "react";
import { useFormik } from "formik";
import { toast } from "react-toastify";
import { useAuth } from "../controllers/hooks/use_auth";
import HttpClient from "../controllers/utils/http_client";
import { Usuario } from "../models";
import LoadingContainer from "./components/loading_container";
import Router from "next/router";

const currentYear = new Date().getFullYear();
// login de la app
const RecuperarClave = () => {
  const [loading, setLoading] = useState<boolean>(false);
  // llama la funcion para iniciar sesion
  const { login } = useAuth();

  // valores del formulario
  const [initialValues, _setInitialValues] = useState<Usuario>({
    number: 0,
    identificacion: "",
    usuario: "",
    contraseña: "",
    nombre: "",
    correo: "",
    telefono: "",
    rol: 2,
    estado: "Activo",
  });
  const [usuarioBodeguero, setusuarioBodeguero] = useState<Array<Usuario>>([]);

  // envia los datos del formulario
  const onSubmit = async (formData: Usuario) => {
    setLoading(true);

    // Buscar si existe un usuario con ese correo y nombre de usuario
    const usuarioEncontrado = usuarioBodeguero.find(
      (u) =>
        u.usuario.toLowerCase() === formData.usuario.toLowerCase() &&
        u.correo.toLowerCase() === formData.correo.toLowerCase()
    );

    if (!usuarioEncontrado) {
      toast.error("Usuario o correo no válido");
      setLoading(false);
      return;
    }

    // Clonar el usuario encontrado, pero actualizar solo la contraseña
    const usuarioActualizado: Usuario = {
      ...usuarioEncontrado,
      contraseña: formData.contraseña, // nueva clave
    };

    try {
      const response = await HttpClient(
        "/api/user",
        "PUT",
        "",
        -1,
        usuarioActualizado
      );
      if (response.success) {
        toast.success("Contraseña reestablecida exitosamente");
        Router.push({ pathname: "/login" });
      } else {
        toast.error(response.message || "Error al actualizar la contraseña");
      }
    } catch (error) {
      console.error(error);
      toast.error("Error inesperado al actualizar la contraseña");
    }

    setLoading(false);
  };

  // maneja los datos y comportamiento del formulario
  const formik = useFormik({
    enableReinitialize: true,
    validateOnMount: true,
    validateOnBlur: true,
    validateOnChange: true,
    initialValues,
    onSubmit,
  });

  const loadUserBod = async () => {
    setLoading(true);
    const response = await HttpClient("/api/user", "GET", "", -1);
    const data: Array<Usuario> = response.data ?? [];

    // Filtrar usuarios con rol === 1

    console.log(data);
    setusuarioBodeguero(data);
    setLoading(false);
  };

  useEffect(() => {
    loadUserBod();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  return (
    <>
      <title>Reestablecimiento contraseña</title>
      <section className="min-h-screen w-full flex items-center justify-center bg-gradient-to-r from-blue-400 via-blue-500 to-blue-600">
        <div className="flex flex-col items-center justify-center rounded-3xl shadow-lg bg-white w-full max-w-md p-8">
          <h2 className="text-center text-3xl font-extrabold text-blue-800 mb-6">
            Reestablecimiento de contraseña
          </h2>

          <LoadingContainer visible={loading} miniVersion>
            <form onSubmit={formik.handleSubmit} className="w-full">
              <div className="mb-6">
                <label
                  htmlFor="userName"
                  className="block text-sm font-medium text-gray-700"
                >
                  Nombre de Usuario
                </label>
                <input
                  type="text"
                  name="usuario"
                  value={formik.values.usuario}
                  onChange={formik.handleChange}
                  placeholder="Ingrese su usuario"
                  className="mt-1 block w-full h-12 px-4 py-2 border border-gray-300 rounded-lg shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
                />
              </div>
              <div className="mb-6">
                <label
                  htmlFor="correo"
                  className="block text-sm font-medium text-gray-700"
                >
                  Correo electronico
                </label>
                <input
                  type="text"
                  name="correo"
                  value={formik.values.correo}
                  onChange={formik.handleChange}
                  placeholder="Ingrese su correo"
                  className="mt-1 block w-full h-12 px-4 py-2 border border-gray-300 rounded-lg shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
                />
              </div>
              <div className="mb-6">
                <label
                  htmlFor="password"
                  className="block text-sm font-medium text-gray-700"
                >
                  Nueva contraseña
                </label>
                <input
                  type="password"
                  name="contraseña"
                  value={formik.values.contraseña}
                  onChange={formik.handleChange}
                  placeholder="Ingrese su contraseña"
                  className="mt-1 block w-full h-12 px-4 py-2 border border-gray-300 rounded-lg shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
                />
              </div>

              <button
                type="submit"
                className="w-full py-3 px-4 bg-blue-500 hover:bg-blue-600 text-white rounded-lg font-semibold transition-colors"
              >
                Recuperar clave
              </button>
            </form>
          </LoadingContainer>
        </div>
      </section>
    </>
  );
};

export default RecuperarClave;



================================================
FILE: pages/registro.tsx
================================================
/* eslint-disable @next/next/no-img-element */
import { useState } from "react";
import { useFormik } from "formik";
import { toast } from "react-toastify";
import { useAuth } from "../controllers/hooks/use_auth";
import HttpClient from "../controllers/utils/http_client";
import { Usuario } from "../models";
import LoadingContainer from "./components/loading_container";
import Router from "next/router";

const currentYear = new Date().getFullYear();
// login de la app
const Register = () => {
  const [loading, setLoading] = useState<boolean>(false);
  // llama la funcion para iniciar sesion
  const { login } = useAuth();

  // valores del formulario
  const [initialValues, _setInitialValues] = useState<Usuario>({
    number: 0,
    identificacion: "",
    usuario: "",
    contraseña: "",
    nombre: "",
    correo: "",
    telefono: "",
    rol: 2,
    estado: "Activo",
  });

  // envia los datos del formulario
  const onSubmit = async (formData: Usuario) => {
    setLoading(true);
    const response = await HttpClient("/api/user", "POST", "", -1, formData);
    if (response.success) {
      const data = response.data;
      login(data);
      console.log(formData);
      toast.success("Usuario creado correctamente");
      Router.push({ pathname: "/login" });
    } else {
      toast.warning(response.message);
    }
    setLoading(false);
  };

  // maneja los datos y comportamiento del formulario
  const formik = useFormik({
    enableReinitialize: true,
    validateOnMount: true,
    validateOnBlur: true,
    validateOnChange: true,
    initialValues,
    onSubmit,
  });

  return (
    <>
      <title>Registro de usuario</title>
      <section className="min-h-screen w-full flex items-center justify-center bg-gradient-to-r from-blue-400 via-blue-500 to-blue-600">
        <div className="flex flex-col items-center justify-center rounded-3xl shadow-lg bg-white w-full max-w-md p-8">
          <h2 className="text-center text-3xl font-extrabold text-blue-800 mb-6">
            Registro de usuario
          </h2>

          <LoadingContainer visible={loading} miniVersion>
            <form onSubmit={formik.handleSubmit} className="w-full">
              <div className="mb-6">
                <label
                  htmlFor="userName"
                  className="block text-sm font-medium text-gray-700"
                >
                  Nombre de Usuario
                </label>
                <input
                  type="text"
                  name="usuario"
                  value={formik.values.usuario}
                  onChange={formik.handleChange}
                  placeholder="Ingrese su usuario"
                  className="mt-1 block w-full h-12 px-4 py-2 border border-gray-300 rounded-lg shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
                />
              </div>
              <div className="mb-6">
                <label
                  htmlFor="password"
                  className="block text-sm font-medium text-gray-700"
                >
                  Contraseña
                </label>
                <input
                  type="password"
                  name="contraseña"
                  value={formik.values.contraseña}
                  onChange={formik.handleChange}
                  placeholder="Ingrese su contraseña"
                  className="mt-1 block w-full h-12 px-4 py-2 border border-gray-300 rounded-lg shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
                />
              </div>
              <div className="mb-6">
                <label
                  htmlFor="nombre"
                  className="block text-sm font-medium text-gray-700"
                >
                  Nombre completo
                </label>
                <input
                  type="text"
                  name="nombre"
                  value={formik.values.nombre}
                  onChange={formik.handleChange}
                  placeholder="Ingrese su nombre"
                  className="mt-1 block w-full h-12 px-4 py-2 border border-gray-300 rounded-lg shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
                />
              </div>
              <div className="mb-6">
                <label
                  htmlFor="identificacion"
                  className="block text-sm font-medium text-gray-700"
                >
                  Identificacion del usuario
                </label>
                <input
                  type="text"
                  name="identificacion"
                  value={formik.values.identificacion}
                  onChange={formik.handleChange}
                  placeholder="Ingrese su identificacion"
                  className="mt-1 block w-full h-12 px-4 py-2 border border-gray-300 rounded-lg shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
                />
              </div>
              <div className="mb-6">
                <label
                  htmlFor="correo"
                  className="block text-sm font-medium text-gray-700"
                >
                  Correo electronico
                </label>
                <input
                  type="text"
                  name="correo"
                  value={formik.values.correo}
                  onChange={formik.handleChange}
                  placeholder="Ingrese su correo"
                  className="mt-1 block w-full h-12 px-4 py-2 border border-gray-300 rounded-lg shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
                />
              </div>
              <div className="mb-6">
                <label
                  htmlFor="userName"
                  className="block text-sm font-medium text-gray-700"
                >
                  Telefono
                </label>
                <input
                  type="text"
                  name="telefono"
                  value={formik.values.telefono}
                  onChange={formik.handleChange}
                  placeholder="Ingrese su telefono"
                  className="mt-1 block w-full h-12 px-4 py-2 border border-gray-300 rounded-lg shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
                />
              </div>

              <button
                type="submit"
                className="w-full py-3 px-4 bg-blue-500 hover:bg-blue-600 text-white rounded-lg font-semibold transition-colors"
              >
                Crear usuario
              </button>
            </form>
          </LoadingContainer>
        </div>
      </section>
    </>
  );
};

export default Register;



================================================
FILE: pages/api/auditory.ts
================================================
import { NextApiRequest, NextApiResponse } from "next";
import dbConnect from "../../database/connect/mongo";
import { AuditoryModel } from "../../database/schemas";
import { Auditory } from "../../models";

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  try {
    // connect to the database
    await dbConnect();

    if (req.method !== 'GET') throw new Error('Invalid method')

    // fetch the posts
    const auditories = await AuditoryModel.find({})

    return res.status(200).json({
      message: "Todas las auditorias",
      data: auditories as Array<Auditory>,
      success: true,
    });

  } catch (error) {
    console.error(error);
    // return the error
    return res.status(500).json({
      message: new Error(error).message,
      success: false,
    });
  }
}



================================================
FILE: pages/api/login.ts
================================================
import { NextApiRequest, NextApiResponse } from "next";
import dbConnect from "../../database/connect/mongo";
import { UserModel } from "../../database/schemas";
import { Usuario } from "../../models";

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  try {
    const { usuario, contraseña } = req.body;
    console.log(req.body)
    // connect to the database
    await dbConnect();

    if (req.method === "POST") {
      // fetch the posts
      const user = await UserModel.findOne(
        { usuario, contraseña },
        { password: 0 }
      );
      console.log(user);

      if (user !== null) {
        return res.status(200).json({
          message: "Bienvenido!",
          data: user as Usuario,
          success: true,
        });
      }

      // return the posts
      return res.status(404).json({
        message: "Verifique los datos ingresados",
        success: false,
      });
    }
    throw new Error("Invalid method");
  } catch (error) {
    // return the error
    return res.status(500).json({
      message: new Error(error).message,
      success: false,
    });
  }
}



================================================
FILE: pages/api/upload.ts
================================================
import fs from "fs";
import path from "path";
import formidable from "formidable";

export const config = {
  api: {
    bodyParser: false, // Desactiva el bodyParser para manejar archivos
  },
};

export default function handler(req, res) {
  if (req.method !== "POST") {
    return res.status(405).json({ message: "Método no permitido" });
  }

  const form = new formidable.IncomingForm();
  form.uploadDir = path.join(process.cwd(), "public/uploads"); // Carpeta donde se guardarán los archivos
  form.keepExtensions = true; // Mantiene la extensión del archivo

  // Procesar la subida del archivo
  form.parse(req, (err, fields, files) => {
    if (err) {
      return res.status(500).json({ message: "Error al subir archivo" });
    }

    const file = files.file;
    const newFilePath = path.join(form.uploadDir, file.newFilename);

    fs.rename(file.filepath, newFilePath, (renameErr) => {
      if (renameErr) {
        return res.status(500).json({ message: "Error al guardar archivo" });
      }

      const fileUrl = `/uploads/${file.newFilename}`;
      res.status(200).json({ success: true, url: fileUrl });
    });
  });
}



================================================
FILE: pages/api/bodegas/[id].ts
================================================
import { NextApiRequest, NextApiResponse } from "next";
import read from "../../../controllers/mongo/bodegas/read";
import dbConnect from "../../../database/connect/mongo";

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  try {
    // connect to the database
    await dbConnect();

    switch (req.method) {
      case "GET":
        return await read(req, res);
      default:
        throw new Error("Invalid method");
    }
  } catch (error) {
    console.error(error);
    // return the error
    return res.status(500).json({
      message: new Error(error).message,
      success: false,
    });
  }
}

export const config = {
  api: {
    responseLimit: false,
  },
};



================================================
FILE: pages/api/bodegas/index.ts
================================================
import { NextApiRequest, NextApiResponse } from "next";
import update from "../../../controllers/mongo/bodegas/update";
import list from "../../../controllers/mongo/bodegas/list";
import dbConnect from "../../../database/connect/mongo";
import create from "../../../controllers/mongo/bodegas/create";

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  try {
    // connect to the database
    await dbConnect();

    switch (req.method) {
      case "GET":
        return await list(req, res);
      case "POST":
        return await create(req, res);
      case "PUT":
        return await update(req, res);
      default:
        throw new Error("Invalid method");
    }
  } catch (error) {
    console.error(error);
    // return the error
    return res.status(500).json({
      message: new Error(error).message,
      success: false,
    });
  }
}

export const config = {
  api: {
    responseLimit: false,
  },
};



================================================
FILE: pages/api/calibracion/[id].ts
================================================
import { NextApiRequest, NextApiResponse } from "next";
import read from "../../../controllers/mongo/calibracion/read";
import remove from "../../../controllers/mongo/calibracion/delete";
import dbConnect from "../../../database/connect/mongo";

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  try {
    // connect to the database
    await dbConnect();

    switch (req.method) {
      case "GET":
        return await read(req, res);
      case "DELETE":
        return await remove(req, res);
      default:
        throw new Error("Invalid method");
    }
  } catch (error) {
    console.error(error);
    // return the error
    return res.status(500).json({
      message: new Error(error).message,
      success: false,
    });
  }
}

export const config = {
  api: {
    responseLimit: false,
  },
};



================================================
FILE: pages/api/calibracion/index.ts
================================================
import { NextApiRequest, NextApiResponse } from "next";
import update from "../../../controllers/mongo/calibracion/update";
import list from "../../../controllers/mongo/calibracion/list";
import dbConnect from "../../../database/connect/mongo";
import create from "../../../controllers/mongo/calibracion/create";

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  try {
    // connect to the database
    await dbConnect();

    switch (req.method) {
      case "GET":
        return await list(req, res);
      case "POST":
        return await create(req, res);
      case "PUT":
        return await update(req, res);
      default:
        throw new Error("Invalid method");
    }
  } catch (error) {
    console.error(error);
    // return the error
    return res.status(500).json({
      message: new Error(error).message,
      success: false,
    });
  }
}

export const config = {
  api: {
    responseLimit: false,
  },
};



================================================
FILE: pages/api/herramientas/[id].ts
================================================
import { NextApiRequest, NextApiResponse } from "next";
import read from "../../../controllers/mongo/herramientas/read";
import remove from "../../../controllers/mongo/herramientas/delete";
import dbConnect from "../../../database/connect/mongo";

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  try {
    // connect to the database
    await dbConnect();

    switch (req.method) {
      case "GET":
        return await read(req, res);
      case "DELETE":
        return await remove(req, res);
      default:
        throw new Error("Invalid method");
    }
  } catch (error) {
    console.error(error);
    // return the error
    return res.status(500).json({
      message: new Error(error).message,
      success: false,
    });
  }
}

export const config = {
  api: {
    responseLimit: false,
  },
};



================================================
FILE: pages/api/herramientas/index.ts
================================================
import { NextApiRequest, NextApiResponse } from "next";
import update from "../../../controllers/mongo/herramientas/update";
import list from "../../../controllers/mongo/herramientas/list";
import dbConnect from "../../../database/connect/mongo";
import create from "../../../controllers/mongo/herramientas/create";

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  try {
    // connect to the database
    await dbConnect();

    switch (req.method) {
      case "GET":
        return await list(req, res);
      case "POST":
        return await create(req, res);
      case "PUT":
        return await update(req, res);
      default:
        throw new Error("Invalid method");
    }
  } catch (error) {
    console.error(error);
    // return the error
    return res.status(500).json({
      message: new Error(error).message,
      success: false,
    });
  }
}

export const config = {
  api: {
    responseLimit: false,
  },
};



================================================
FILE: pages/api/modelos/[id].ts
================================================
import { NextApiRequest, NextApiResponse } from "next";
import read from "../../../controllers/mongo/modelos/read";
import dbConnect from "../../../database/connect/mongo";

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  try {
    // connect to the database
    await dbConnect();

    switch (req.method) {
      case "GET":
        return await read(req, res);
      default:
        throw new Error("Invalid method");
    }
  } catch (error) {
    console.error(error);
    // return the error
    return res.status(500).json({
      message: new Error(error).message,
      success: false,
    });
  }
}

export const config = {
  api: {
    responseLimit: false,
  },
};



================================================
FILE: pages/api/modelos/index.ts
================================================
import { NextApiRequest, NextApiResponse } from "next";
import update from "../../../controllers/mongo/modelos/update";
import list from "../../../controllers/mongo/modelos/list";
import dbConnect from "../../../database/connect/mongo";
import create from "../../../controllers/mongo/modelos/create";

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  try {
    // connect to the database
    await dbConnect();

    switch (req.method) {
      case "GET":
        return await list(req, res);
      case "POST":
        return await create(req, res);
      case "PUT":
        return await update(req, res);
      default:
        throw new Error("Invalid method");
    }
  } catch (error) {
    console.error(error);
    // return the error
    return res.status(500).json({
      message: new Error(error).message,
      success: false,
    });
  }
}

export const config = {
  api: {
    responseLimit: false,
  },
};



================================================
FILE: pages/api/solicitudes/[id].ts
================================================
import { NextApiRequest, NextApiResponse } from "next";
import read from "../../../controllers/mongo/solicitudes/read";
import remove from "../../../controllers/mongo/solicitudes/delete";
import dbConnect from "../../../database/connect/mongo";

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  try {
    // connect to the database
    await dbConnect();

    switch (req.method) {
      case "GET":
        return await read(req, res);
      case "DELETE":
        return await remove(req, res);
      default:
        throw new Error("Invalid method");
    }
  } catch (error) {
    console.error(error);
    // return the error
    return res.status(500).json({
      message: new Error(error).message,
      success: false,
    });
  }
}

export const config = {
  api: {
    responseLimit: false,
  },
};



================================================
FILE: pages/api/solicitudes/index.ts
================================================
import { NextApiRequest, NextApiResponse } from "next";
import update from "../../../controllers/mongo/solicitudes/update";
import list from "../../../controllers/mongo/solicitudes/list";
import dbConnect from "../../../database/connect/mongo";
import create from "../../../controllers/mongo/solicitudes/create";

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  try {
    // connect to the database
    await dbConnect();

    switch (req.method) {
      case "GET":
        return await list(req, res);
      case "POST":
        return await create(req, res);
      case "PUT":
        return await update(req, res);
      default:
        throw new Error("Invalid method");
    }
  } catch (error) {
    console.error(error);
    // return the error
    return res.status(500).json({
      message: new Error(error).message,
      success: false,
    });
  }
}

export const config = {
  api: {
    responseLimit: false,
  },
};



================================================
FILE: pages/api/ubicaciones/[id].ts
================================================
import { NextApiRequest, NextApiResponse } from "next";
import read from "../../../controllers/mongo/ubicaciones/read";
import dbConnect from "../../../database/connect/mongo";

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  try {
    // connect to the database
    await dbConnect();

    switch (req.method) {
      case "GET":
        return await read(req, res);
      default:
        throw new Error("Invalid method");
    }
  } catch (error) {
    console.error(error);
    // return the error
    return res.status(500).json({
      message: new Error(error).message,
      success: false,
    });
  }
}

export const config = {
  api: {
    responseLimit: false,
  },
};



================================================
FILE: pages/api/ubicaciones/index.ts
================================================
import { NextApiRequest, NextApiResponse } from "next";
import update from "../../../controllers/mongo/ubicaciones/update";
import list from "../../../controllers/mongo/ubicaciones/list";
import dbConnect from "../../../database/connect/mongo";
import create from "../../../controllers/mongo/ubicaciones/create";

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  try {
    // connect to the database
    await dbConnect();

    switch (req.method) {
      case "GET":
        return await list(req, res);
      case "POST":
        return await create(req, res);
      case "PUT":
        return await update(req, res);
      default:
        throw new Error("Invalid method");
    }
  } catch (error) {
    console.error(error);
    // return the error
    return res.status(500).json({
      message: new Error(error).message,
      success: false,
    });
  }
}

export const config = {
  api: {
    responseLimit: false,
  },
};



================================================
FILE: pages/api/user/[id].ts
================================================
import { NextApiRequest, NextApiResponse } from "next";
import dbConnect from "../../../database/connect/mongo";
import { UserModel } from "../../../database/schemas";
import remove from "../../../controllers/mongo/user/delete";

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  await dbConnect();

  const { method } = req;
  const { id } = req.query;

  if (method === "GET") {
    try {
      //@ts-ignore
      const user = await UserModel.findById(id);

      if (!user) {
        return res.status(404).json({
          message: "Usuario no encontrado",
          success: false,
        });
      }

      return res.status(200).json({
        message: "Usuario encontrado",
        data: user,
        success: true,
      });
    } catch (error) {
      return res.status(500).json({
        message: "Error interno del servidor",
        success: false,
      });
    }
  }

  if (method === "PUT") {
    try {
      const { holidays } = req.body;

      //@ts-ignore
      const user = await UserModel.findByIdAndUpdate(
        id,
        { holidays },
        { new: true }
      );

      if (!user) {
        return res.status(404).json({
          message: "Usuario no encontrado",
          success: false,
        });
      }

      return res.status(200).json({
        message: "Días de vacaciones actualizados correctamente",
        data: user,
        success: true,
      });
    } catch (error) {
      return res.status(500).json({
        message: "Error interno del servidor",
        success: false,
      });
    }
  }

  if(method === "DELETE") {
    await remove(req, res)
  }

  return res.status(405).json({
    message: "Método no permitido",
    success: false,
  });
}



================================================
FILE: pages/api/user/index.ts
================================================
import { NextApiRequest, NextApiResponse } from "next";
import create from '../../../controllers/mongo/user/create';
import update from '../../../controllers/mongo/user/update';
import list from '../../../controllers/mongo/user/list';
import dbConnect from "../../../database/connect/mongo";

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  try {
    // connect to the database
    await dbConnect();

    switch (req.method) {
      case 'GET':
        return await list(req, res)
      case 'POST':
        return await create(req, res)
      case 'PUT':
        return await update(req, res)
      default:
        throw new Error('Invalid method')
    }
  } catch (error) {
    console.error(error);
    // return the error
    return res.status(500).json({
      message: new Error(error).message,
      success: false,
    });
  }
}




================================================
FILE: pages/bodegas/index.tsx
================================================
import { Button } from "react-bootstrap";
import Sidebar from "../components/sidebar";
import { toast } from "react-toastify";
import { useAuth } from "../../controllers/hooks/use_auth";
import { useEffect, useRef, useState } from "react";
import HttpClient from "../../controllers/utils/http_client";
import { Bodega, Herramienta } from "../../models";
import TreeTable, { ColumnData } from "../components/tree_table";
import ConfirmModal from "../components/modals/confirm";
import { ExcelExport } from "@progress/kendo-react-excel-export";
import { CheckPermissions } from "../../controllers/utils/check_permissions";
import Router from "next/router";

export const BodegasPage = () => {
  const { auth } = useAuth();
  const [tableData, setTableData] = useState<Array<Bodega>>([]);
  const [loading, setLoading] = useState<boolean>(true);
  const [itemToDelete, setItemToDelete] = useState<string>(null);
  const excelExporter = useRef<ExcelExport>(null);

  // Cargar datos de herramientas
  const loadData = async () => {
    setLoading(true);
    const response = await HttpClient(
      "/api/bodegas",
      "GET",
      auth.usuario,
      auth.rol
    );
    const bodegas = response.data ?? [];

    // Si el rol es 0, mostrar todas las bodegas
    const bodegasFiltradas =
      auth.rol === 0
        ? bodegas
        : bodegas.filter(
            (bodega) =>
              bodega.bodegueroAsignado.toLowerCase() ===
              auth.usuario.toLowerCase()
          );

    setTableData(bodegasFiltradas);
    setLoading(false);
  };

  useEffect(() => {
    loadData();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  const columns: ColumnData[] = [
    {
      dataField: "nombreBodega",
      caption: "Nombre de la bodega",
      alignment: "center",
      cssClass: "bold",
    },
    {
      dataField: "bodegueroAsignado",
      caption: "Bodeguero Asignado",
      alignment: "center",
      cssClass: "bold",
    },
    {
      dataField: "creador",
      caption: "Creador",
      alignment: "center",
      cssClass: "bold",
    },
    {
      dataField: "fechaDeCreacion",
      caption: "Fecha de creacion ",
      alignment: "center",
      cssClass: "bold",
    },
  ];

  // Exportar a Excel
  const exportToExcel = () => {
    if (excelExporter.current) {
      excelExporter.current.save();
    }
  };

  // ✅ Exportar a PDF corregido
  //const exportToPDF = () => {
  //  const doc = new jsPDF();
  //  doc.text("Reporte de Herramientas", 14, 10);
  //
  //  const headers = [
  //    [
  //      "Código",
  //      "Estado",
  //      "Nombre",
  //      "N° Parte",
  //      "Serie",
  //      "Modelo",
  //      "Marca",
  //      "Ubicación",
  //      "Cantidad",
  //      "Observación",
  //    ],
  //  ];
  //
  //  const data = tableData.herramientas.map((h) => [
  //    h.codigo,
  //    h.estado,
  //    h.nombre,
  //    h.NParte,
  //    h.serie,
  //    h.modelo,
  //    h.marca,
  //    h.ubicacion,
  //    h.cantidad,
  //    h.observacion,
  //  ]);
  //
  //  autoTable(doc, {
  //    // ✅ Pasamos doc como argumento
  //    head: headers,
  //    body: data,
  //    startY: 20,
  //    styles: { fontSize: 8 },
  //    headStyles: { fillColor: [22, 160, 133] }, // Verde para encabezados
  //  });
  //
  //  doc.save("Reporte_Herramientas.pdf");
  //};

  const showConfirmModal = (factureId: string) => setItemToDelete(factureId);
  const hideConfirmModal = () => setItemToDelete(null);

  const buttons = {
    edit: (rowData: Herramienta) =>
      CheckPermissions(auth, [0, 1])
        ? Router.push({
            pathname: "/bodegas/editar/" + (rowData.id as string),
          })
        : toast.error("No puedes acceder"),
    show: (rowData: Herramienta) =>
      CheckPermissions(auth, [0, 1])
        ? Router.push({
            pathname: "/bodegas/show/" + (rowData.id as string),
          })
        : toast.error("No puedes acceder"),
  };

  return (
    <>
      <div className="flex h-screen">
        <div className="md:w-1/6 max-w-none">
          <Sidebar />
        </div>
        <div className="w-12/12 md:w-5/6 bg-blue-100">
          <div className="bg-white w-11/12 h-5/6 mx-auto">
            <div className="mt-6">
              <p className="md:text-4xl text-xl text-center pt-5 font-extrabold text-blue-500">
                Todas las bodegas
              </p>
            </div>

            {/* Botones de exportación */}
            <div className="flex justify-center gap-4 mt-4">
              {/* <Button
                className="bg-green-500 text-white px-4 py-2 rounded"
                onClick={exportToExcel}
              >
                Exportar a Excel
              </Button> */}
              {/* <Button
                className="bg-red-500 text-white px-4 py-2 rounded"
                onClick={exportToPDF}
              >
                Exportar a PDF
              </Button> */}
            </div>

            <Button
              className="text-white bg-blue-400 hover:bg-blue-500 focus:outline-none focus:ring-4 focus:ring-blue-300 font-medium rounded-full text-sm px-5 py-3 text-center mx-2 mb-2 mt-3 dark:focus:ring-blue-900"
              onClick={() =>
                CheckPermissions(auth, [0])
                  ? Router.push({ pathname: "/bodegas/create" })
                  : toast.info("No puede ingresar bodegas")
              }
            >
              Crear bodega
            </Button>

            {/* Tabla de herramientas */}
            <div className="p-2">
              <TreeTable
                keyExpr="id"
                dataSource={tableData}
                buttons={buttons}
                columns={columns}
                searchPanel={true}
                buttonsFirst
                paging
                showNavigationButtons
                showNavigationInfo
                pageSize={10}
                infoText={(actual, total, items) =>
                  `Página ${actual} de ${total} (${items} bodegas)`
                }
              />
            </div>

            {/* Componente para exportar a Excel */}
            {/* <ExcelExport
              data={tableData.herramientas}
              ref={excelExporter}
              fileName="Inventario_Herramientas.xlsx"
            >
              <ExcelExportColumn field="codigo" title="Codigo" />
              <ExcelExportColumn field="estado" title="Estado" />
              <ExcelExportColumn field="nombre" title="Nombre" />
              <ExcelExportColumn field="NParte" title="Numero de parte" />
              <ExcelExportColumn field="serie" title="Serie" />
              <ExcelExportColumn field="modelo" title="Modelo" />
              <ExcelExportColumn field="marca" title="Marca" />
              <ExcelExportColumn field="ubicacion" title="Ubicacion" />
              <ExcelExportColumn field="cantidad" title="Cantidad" />
              <ExcelExportColumn field="observacion" title="Observacion" />
            </ExcelExport> */}
          </div>
        </div>
      </div>

      {/* Modal de confirmación para eliminar herramientas */}
      <ConfirmModal
        visible={itemToDelete !== null}
        close={() => setItemToDelete(null)}
        onDone={async () => {
          await HttpClient(
            `/api/herramientas/${itemToDelete}`,
            "DELETE",
            auth.usuario,
            auth.rol
          );
          setItemToDelete(null);
          toast.success("Herramienta eliminada correctamente");
          await loadData();
        }}
      />
    </>
  );
};

export default BodegasPage;



================================================
FILE: pages/bodegas/create/index.tsx
================================================
/* eslint-disable react/no-unescaped-entities */
import { Button } from "react-bootstrap";
import Sidebar from "../../components/sidebar";
import { useAuth } from "../../../controllers/hooks/use_auth";
import { useFormik } from "formik";
import Router from "next/router";
import { toast } from "react-toastify";
import {
  Bodega,
  Herramienta,
  ModelosHerramienta,
  ResponseData,
  Ubicaciones,
  Usuario,
} from "../../../models";
import HttpClient from "../../../controllers/utils/http_client";
import { useEffect, useState } from "react";
import { UploadSolicitudeImages } from "../../../controllers/utils/upload_solicitude_images";
import { ref, uploadBytesResumable, getDownloadURL } from "firebase/storage";
import { storage } from "../../../controllers/firebase/config";
import FormatedDate from "../../../controllers/utils/formated_date";

export const BodegasCreate = () => {
  const { auth } = useAuth();
  const [loading, setLoading] = useState<boolean>(false);
  const [image, setImage] = useState<File>(null);
  const [initialValues, _setInitialValues] = useState<Bodega>({
    number: 0,
    fechaDeCreacion: FormatedDate(),
    creador: auth.nombre,
    herramientas: [],
    bodegueroAsignado: "",
    nombreBodega: ""
  });
  const [usuarioBodeguero, setusuarioBodeguero] = useState<Array<Usuario>>([]);
  const [modelos, setmodelos] = useState<Array<ModelosHerramienta>>([]);
  const [ubicaciones, setubicaciones] = useState<Array<Ubicaciones>>([]);
  const [herramientaTemp, setHerramientaTemp] = useState<Herramienta>({
    nombre: "",
    codigo: "",
    descripcion: "",
    serie: "",
    modelo: "",
    marca: "",
    NParte: "",
    ubicacion: "",
    estado: "",
    imagen: "",
    tipo: "",
    cantidad: 1,
    observacion: "",
    calibracion: "",
  });

  const loadUserBod = async () => {
    setLoading(true);
    const response = await HttpClient(
      "/api/user",
      "GET",
      auth.usuario,
      auth.rol
    );
    const data: Array<Usuario> = response.data ?? [];

    // Filtrar usuarios con rol === 1
    const bodegueros = data.filter((usuario) => usuario.rol === 1);

    console.log(bodegueros);
    setusuarioBodeguero(bodegueros);
    setLoading(false);
  };

  const loadModelos = async () => {
    setLoading(true);
    const response = await HttpClient(
      "/api/modelos",
      "GET",
      auth.usuario,
      auth.rol
    );
    const data: Array<ModelosHerramienta> = response.data ?? [];

    console.log(data);
    setmodelos(data);
    setLoading(false);
  };

  const loadUbiciones = async () => {
    setLoading(true);
    const response = await HttpClient(
      "/api/ubicaciones",
      "GET",
      auth.usuario,
      auth.rol
    );
    const data: Array<Ubicaciones> = response.data ?? [];

    console.log(data);
    setubicaciones(data);
    setLoading(false);
  };

  useEffect(() => {
    loadUserBod();
    loadModelos();
    loadUbiciones();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  const formik = useFormik<Bodega>({
    enableReinitialize: true,
    validateOnMount: true,
    validateOnBlur: true,
    validateOnChange: true,
    initialValues,
    onSubmit: async (formData) => {
      setLoading(true);
      try {
        const response = await HttpClient(
          "/api/bodegas",
          "POST",
          auth.usuario,
          auth.rol,
          formData
        );

        toast.success("Bodega guardada exitosamente.");
        console.log("Respuesta del backend:", response);

        Router.back();
      } catch (error) {
        console.error("Error al guardar la bodega:", error);
        toast.error("Error al guardar la bodega.");
      } finally {
        setLoading(false);
      }
    },
  });

  return (
    <>
      <div className="flex h-screen">
        <div className="md:w-1/6 max-w-none">
          <Sidebar />
        </div>
        <div className="w-12/12 md:w-5/6 bg-blue-100">
          <div className="bg-white w-5/6 h-auto mx-auto my-10">
            <div>
              <p className="md:text-3xl text-xl text-center pt-5 font-extrabold text-blue-500">
                Crear Bodega
              </p>
            </div>

            <div className="grid grid-cols-3 gap-4 px-4 py-2">
            <div>
                <label>Nombre de la bodega</label>
                <input
                  type="text"
                  placeholder="Escribe el Nombre de la bodega"
                  name="nombreBodega"
                  value={formik.values.nombreBodega}
                  onChange={formik.handleChange}
                  className="shadow-sm bg-gray-50 border border-gray-300 text-gray-900 text-sm rounded-lg focus:ring-blue-500 focus:border-blue-500 block w-full p-2.5 dark:bg-gray-700 dark:border-gray-600 dark:placeholder-gray-400 dark:text-white dark:focus:ring-blue-500 dark:focus:border-blue-500 dark:shadow-sm-light"
                />
              </div>
              <div>
                <label>¿Quién crea la bodega?</label>
                <input
                  type="text"
                  placeholder="¿Quién crea la bodega?"
                  name="creador"
                  value={formik.values.creador}
                  onChange={formik.handleChange}
                  className="shadow-sm bg-gray-50 border border-gray-300 text-gray-900 text-sm rounded-lg focus:ring-blue-500 focus:border-blue-500 block w-full p-2.5 dark:bg-gray-700 dark:border-gray-600 dark:placeholder-gray-400 dark:text-white dark:focus:ring-blue-500 dark:focus:border-blue-500 dark:shadow-sm-light"
                />
              </div>

              <div>
                <label>Fecha de creacion</label>
                <input
                  type="text"
                  placeholder="Fecha de creacion"
                  name="fechaDeCreacion"
                  value={formik.values.fechaDeCreacion}
                  onChange={formik.handleChange}
                  className="shadow-sm bg-gray-50 border border-gray-300 text-gray-900 text-sm rounded-lg focus:ring-blue-500 focus:border-blue-500 block w-full p-2.5 dark:bg-gray-700 dark:border-gray-600 dark:placeholder-gray-400 dark:text-white dark:focus:ring-blue-500 dark:focus:border-blue-500 dark:shadow-sm-light"
                />
              </div>
              <div>
                <label>Bodeguero asignado</label>
                <input
                  type="text"
                  placeholder="Bodeguero asignado"
                  list="usuarios-creadores"
                  name="bodegueroAsignado"
                  value={formik.values.bodegueroAsignado}
                  onChange={formik.handleChange}
                  className="shadow-sm bg-gray-50 border border-gray-300 text-gray-900 text-sm rounded-lg focus:ring-blue-500 focus:border-blue-500 block w-full p-2.5 dark:bg-gray-700 dark:border-gray-600 dark:placeholder-gray-400 dark:text-white dark:focus:ring-blue-500 dark:focus:border-blue-500 dark:shadow-sm-light"
                />
                <datalist id="usuarios-creadores">
                  {usuarioBodeguero.map((usuario) => (
                    <option key={usuario.id} value={usuario.nombre} />
                  ))}
                </datalist>
              </div>
            </div>

            <div className="text-center py-5">
              <button
                type="button"
                onClick={() => formik.handleSubmit()}
                className="px-6 py-2 bg-green-600 text-white rounded hover:bg-green-700"
                disabled={loading}
              >
                {loading ? "Guardando..." : "Guardar Bodega"}
              </button>
            </div>
          </div>
        </div>
      </div>
    </>
  );
};

export default BodegasCreate;



================================================
FILE: pages/bodegas/editar/[id].tsx
================================================
/* eslint-disable react/jsx-no-target-blank */
// Este componente permite editar una bodega: ver, agregar, editar y eliminar herramientas asociadas

import { useEffect, useState } from "react";
import { useFormik } from "formik";
import { toast } from "react-toastify";
import Router from "next/router";
import { useAuth } from "../../../controllers/hooks/use_auth";
import HttpClient from "../../../controllers/utils/http_client";
import Sidebar from "../../components/sidebar";
import {
  Bodega,
  Herramienta,
  ModelosHerramienta,
  Ubicaciones,
  ResponseData,
} from "../../../models";
import { ref, uploadBytesResumable, getDownloadURL } from "firebase/storage";
import { storage } from "../../../controllers/firebase/config";

const EditarBodega = () => {
  const { auth } = useAuth();
  const [loading, setLoading] = useState(false);
  const [initialValues, setInitialValues] = useState<Bodega | null>(null);
  const [editingToolIndex, setEditingToolIndex] = useState<number | null>(null);
  const [toolTemp, setToolTemp] = useState<Herramienta>({
    nombre: "",
    codigo: "",
    descripcion: "",
    serie: "",
    modelo: "",
    marca: "",
    NParte: "",
    ubicacion: "",
    estado: "",
    imagen: "",
    tipo: "",
    cantidad: 1,
    observacion: "",
    calibracion: "",
  });
  const [image, setImage] = useState<File | null>(null);
  const [modelos, setmodelos] = useState<Array<ModelosHerramienta>>([]);
  const [ubicaciones, setubicaciones] = useState<Array<Ubicaciones>>([]);

  const loadModelos = async () => {
    setLoading(true);
    const response = await HttpClient(
      "/api/modelos",
      "GET",
      auth.usuario,
      auth.rol
    );
    setmodelos(response.data ?? []);
    setLoading(false);
  };

  const loadUbiciones = async () => {
    setLoading(true);
    const response = await HttpClient(
      "/api/ubicaciones",
      "GET",
      auth.usuario,
      auth.rol
    );
    setubicaciones(response.data ?? []);
    setLoading(false);
  };

  const loadData = async () => {
    if (Router.asPath !== Router.route) {
      setLoading(true);
      const bodegaID = Router.query.id as string;
      const response: ResponseData = await HttpClient(
        `/api/bodegas/${bodegaID}`,
        "GET",
        auth.usuario,
        auth.rol
      );

      if (response.success) {
        setInitialValues(response.data);
      } else {
        toast.error("Bodega no encontrada");
      }
      setLoading(false);
    } else {
      setTimeout(loadData, 1000);
    }
  };

  useEffect(() => {
    loadData();
    loadModelos();
    loadUbiciones();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  const formik = useFormik<Bodega>({
    enableReinitialize: true,
    initialValues: initialValues || {
      number: 0,
      creador: "",
      fechaDeCreacion: "",
      bodegueroAsignado: "",
      nombreBodega: "",
      herramientas: [],
    },
    onSubmit: async (formData) => {
      setLoading(true);
      const response: ResponseData = await HttpClient(
        `/api/bodegas`,
        "PUT",
        auth.usuario,
        auth.rol,
        formData
      );

      if (response.success) {
        toast.success("Bodega actualizada correctamente!");
        Router.push(`/bodegas`);
      } else {
        toast.warning(response.message);
      }
      setLoading(false);
    },
  });

  const handleToolSave = async () => {
    if (!toolTemp.nombre || !toolTemp.codigo) {
      toast.warning("Faltan campos obligatorios.");
      return;
    }

    let imageUrl = toolTemp.imagen;
    if (image) {
      try {
        const storageRef = ref(storage, `herramientas/${image.name}`);
        const uploadTask = uploadBytesResumable(storageRef, image);
        await new Promise<void>((resolve, reject) => {
          uploadTask.on(
            "state_changed",
            () => {},
            (error) => reject(error),
            async () => {
              imageUrl = await getDownloadURL(uploadTask.snapshot.ref);
              resolve();
            }
          );
        });
      } catch (error) {
        toast.error("Error subiendo la imagen");
        return;
      }
    }

    const nueva = { ...toolTemp, imagen: imageUrl };
    const herramientas = [...formik.values.herramientas];

    if (editingToolIndex !== null) {
      herramientas[editingToolIndex] = nueva;
    } else {
      herramientas.push(nueva);
    }

    formik.setFieldValue("herramientas", herramientas);
    setToolTemp({
      nombre: "",
      codigo: "",
      descripcion: "",
      serie: "",
      modelo: "",
      marca: "",
      NParte: "",
      ubicacion: "",
      estado: "",
      imagen: "",
      tipo: "",
      cantidad: 1,
      observacion: "",
      calibracion: "",
    });
    setImage(null);
    setEditingToolIndex(null);
  };

  const handleToolEdit = (index: number) => {
    setEditingToolIndex(index);
    setToolTemp(formik.values.herramientas[index]);
  };

  const handleToolDelete = (index: number) => {
    const updated = formik.values.herramientas.filter((_, i) => i !== index);
    formik.setFieldValue("herramientas", updated);
  };

  return (
    <div className="flex h-screen">
      <div className="md:w-1/6 max-w-none">
        <Sidebar />
      </div>
      <div className="w-12/12 md:w-5/6 bg-blue-100">
        <div className="w-full bg-blue-100 p-8">
          <div className="bg-white p-6 rounded shadow mx-auto">
            <h2 className="text-3xl font-bold text-center text-blue-600 mb-4">
              Editar Bodega #{initialValues?.number}
            </h2>

            <form onSubmit={formik.handleSubmit} className="space-y-4">
              <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
                <input
                  disabled
                  value={formik.values.creador}
                  name="creador"
                  className="p-2 border rounded"
                />
                <input
                  disabled
                  value={formik.values.fechaDeCreacion}
                  name="fechaDeCreacion"
                  className="p-2 border rounded"
                />
                <input
                  disabled
                  value={formik.values.bodegueroAsignado}
                  name="bodegueroAsignado"
                  onChange={formik.handleChange}
                  className="p-2 border rounded"
                />
              </div>

              <h3 className="text-xl font-semibold mt-6">Herramientas</h3>

              <div className="grid grid-cols-2 gap-4">
                <input
                  value={toolTemp.nombre}
                  placeholder="Nombre"
                  onChange={(e) =>
                    setToolTemp({ ...toolTemp, nombre: e.target.value })
                  }
                  className="p-2 border rounded"
                />
                <input
                  value={toolTemp.codigo}
                  placeholder="Código"
                  onChange={(e) =>
                    setToolTemp({ ...toolTemp, codigo: e.target.value })
                  }
                  className="p-2 border rounded"
                />
                <input
                  value={toolTemp.descripcion}
                  placeholder="Descripción"
                  onChange={(e) =>
                    setToolTemp({ ...toolTemp, descripcion: e.target.value })
                  }
                  className="p-2 border rounded"
                />
                <input
                  value={toolTemp.serie}
                  placeholder="Serie"
                  onChange={(e) =>
                    setToolTemp({ ...toolTemp, serie: e.target.value })
                  }
                  className="p-2 border rounded"
                />
                <select
                  value={toolTemp.modelo}
                  onChange={(e) =>
                    setToolTemp({ ...toolTemp, modelo: e.target.value })
                  }
                  className="p-2 border rounded"
                >
                  <option value="">Seleccione un modelo</option>
                  {modelos.map((m) => (
                    <option key={m.id} value={m.nombre}>
                      {m.nombre}
                    </option>
                  ))}
                </select>
                <input
                  value={toolTemp.marca}
                  placeholder="Marca"
                  onChange={(e) =>
                    setToolTemp({ ...toolTemp, marca: e.target.value })
                  }
                  className="p-2 border rounded"
                />
                <input
                  value={toolTemp.NParte}
                  placeholder="N° Parte"
                  onChange={(e) =>
                    setToolTemp({ ...toolTemp, NParte: e.target.value })
                  }
                  className="p-2 border rounded"
                />
                <select
                  value={toolTemp.ubicacion}
                  onChange={(e) =>
                    setToolTemp({ ...toolTemp, ubicacion: e.target.value })
                  }
                  className="p-2 border rounded"
                >
                  <option value="">Seleccione ubicación</option>
                  {ubicaciones.map((u) => (
                    <option key={u.id} value={u.nombre}>
                      {u.nombre}
                    </option>
                  ))}
                </select>
                <select
                  value={toolTemp.estado}
                  onChange={(e) =>
                    setToolTemp({ ...toolTemp, estado: e.target.value })
                  }
                  className="p-2 border rounded"
                >
                  <option value="">Seleccione estado</option>
                  <option value="Disponible">Disponible</option>
                  <option value="En uso">En uso</option>
                </select>
                <select
                  value={toolTemp.calibracion}
                  onChange={(e) =>
                    setToolTemp({ ...toolTemp, calibracion: e.target.value })
                  }
                  className="p-2 border rounded"
                >
                  <option value="">Seleccione Calibracion</option>
                  <option value="Calibrada">Calibrada</option>
                  <option value="No calibrada">No calibrada</option>
                </select>
                <input
                  value={toolTemp.tipo}
                  placeholder="Tipo"
                  onChange={(e) =>
                    setToolTemp({ ...toolTemp, tipo: e.target.value })
                  }
                  className="p-2 border rounded"
                />
                <input
                  value={toolTemp.observacion}
                  placeholder="Observación"
                  onChange={(e) =>
                    setToolTemp({ ...toolTemp, observacion: e.target.value })
                  }
                  className="p-2 border rounded"
                />
                <input
                  type="file"
                  accept="image/*,application/pdf"
                  onChange={(e) => setImage(e.target.files?.[0] || null)}
                  className="p-2 border rounded"
                />
              </div>

              <button
                type="button"
                onClick={handleToolSave}
                className="bg-blue-500 text-white px-4 py-2 rounded"
              >
                {editingToolIndex !== null
                  ? "Guardar edición"
                  : "Agregar herramienta"}
              </button>

              <table className="min-w-full mt-6 table-auto border border-gray-300 rounded">
                <thead className="bg-gray-100">
                  <tr>
                    <th className="px-4 py-2 text-left text-sm font-medium text-gray-700">
                      Nombre
                    </th>
                    <th className="px-4 py-2 text-left text-sm font-medium text-gray-700">
                      Código
                    </th>
                    <th className="px-4 py-2 text-left text-sm font-medium text-gray-700">
                      Serie
                    </th>
                    <th className="px-4 py-2 text-left text-sm font-medium text-gray-700">
                      Modelo
                    </th>
                    <th className="px-4 py-2 text-left text-sm font-medium text-gray-700">
                      Marca
                    </th>
                    <th className="px-4 py-2 text-left text-sm font-medium text-gray-700">
                      N° Parte
                    </th>
                    <th className="px-4 py-2 text-left text-sm font-medium text-gray-700">
                      Ubicación
                    </th>
                    <th className="px-4 py-2 text-left text-sm font-medium text-gray-700">
                      Estado
                    </th>
                    <th className="px-4 py-2 text-left text-sm font-medium text-gray-700">
                      Calibración
                    </th>
                    <th className="px-4 py-2 text-left text-sm font-medium text-gray-700">
                      Imagen
                    </th>
                    <th className="px-4 py-2 text-center text-sm font-medium text-gray-700">
                      Acciones
                    </th>
                  </tr>
                </thead>
                <tbody>
                  {formik.values.herramientas.map((h, index) => (
                    <tr key={index} className="border-t">
                      <td className="px-4 py-2 text-sm">{h.nombre}</td>
                      <td className="px-4 py-2 text-sm">{h.codigo}</td>
                      <td className="px-4 py-2 text-sm">{h.serie}</td>
                      <td className="px-4 py-2 text-sm">{h.modelo}</td>
                      <td className="px-4 py-2 text-sm">{h.marca}</td>
                      <td className="px-4 py-2 text-sm">{h.NParte}</td>
                      <td className="px-4 py-2 text-sm">{h.ubicacion}</td>
                      <td className="px-4 py-2 text-sm">{h.estado}</td>
                      <td className="px-4 py-2 text-sm">{h.calibracion}</td>
                      <td className="px-4 py-2 text-sm">
                        <a
                          href={h.imagen}
                          target="_blank"
                          rel="noopener noreferrer"
                          className="text-blue-500 underline"
                        >
                          Ver imagen
                        </a>
                      </td>
                      <td className="px-4 py-2 text-center flex justify-center gap-2">
                        <button
                          type="button"
                          onClick={() => handleToolEdit(index)}
                          className="bg-yellow-500 hover:bg-yellow-600 text-white px-3 py-1 rounded text-sm"
                        >
                          Editar
                        </button>
                        <button
                          type="button"
                          onClick={() => handleToolDelete(index)}
                          className="bg-red-600 hover:bg-red-700 text-white px-3 py-1 rounded text-sm"
                        >
                          Eliminar
                        </button>
                      </td>
                    </tr>
                  ))}
                </tbody>
              </table>

              <div className="text-center mt-8">
                <button
                  type="submit"
                  className="bg-green-600 text-white px-6 py-2 rounded hover:bg-green-700"
                >
                  Guardar Cambios
                </button>
              </div>
            </form>
          </div>
        </div>
      </div>
    </div>
  );
};

export default EditarBodega;



================================================
FILE: pages/bodegas/show/[id].tsx
================================================
/* eslint-disable @next/next/no-img-element */
import { useState, useEffect, useRef } from "react";
import Router from "next/router";
import { toast } from "react-toastify";
import { useAuth } from "../../../controllers/hooks/use_auth";
import HttpClient from "../../../controllers/utils/http_client";
import { Bodega, ResponseData } from "../../../models";
import Sidebar from "../../components/sidebar";
import {
  ExcelExport,
  ExcelExportColumn,
} from "@progress/kendo-react-excel-export";
import jsPDF from "jspdf";
import autoTable from "jspdf-autotable";

const InformacionBodega = () => {
  const { auth } = useAuth();
  const [loading, setLoading] = useState(false);
  const [bodega, setBodega] = useState<Bodega | null>(null);
  const excelExporter = useRef<any>(null);

  useEffect(() => {
    const loadData = async () => {
      if (Router.asPath !== Router.route) {
        setLoading(true);
        const bodegaID = Router.query.id as string;
        const response: ResponseData = await HttpClient(
          `/api/bodegas/${bodegaID}`,
          "GET",
          auth.usuario,
          auth.rol
        );
        if (response.success) {
          setBodega(response.data);
        } else {
          toast.error("Bodega no encontrada.");
        }
        setLoading(false);
      }
    };

    loadData();
  }, [auth]);

  const exportToExcel = () => {
    if (excelExporter.current) {
      excelExporter.current.save();
    }
  };

  const exportToPDF = () => {
    const doc = new jsPDF();
    doc.text(`Reporte de Herramientas - Bodega: ${bodega?.nombreBodega}`, 14, 10);

    const headers = [
      [
        "Código",
        "Estado",
        "Nombre",
        "N° Parte",
        "Serie",
        "Modelo",
        "Marca",
        "Ubicación",
        "Cantidad",
        "Observación",
      ],
    ];

    const data = bodega?.herramientas.map((h) => [
      h.codigo,
      h.estado,
      h.nombre,
      h.NParte,
      h.serie,
      h.modelo,
      h.marca,
      h.ubicacion,
      h.cantidad,
      h.observacion,
    ]);

    autoTable(doc, {
      head: headers,
      body: data || [],
      startY: 20,
      styles: { fontSize: 8 },
      headStyles: { fillColor: [41, 128, 185] },
    });

    doc.save("Reporte_Herramientas.pdf");
  };

  return (
    <div className="flex h-screen">
      <Sidebar />
      <div className="w-full bg-blue-100 p-8 overflow-y-auto">
        <div className="bg-white rounded-lg shadow p-6 max-w-6xl mx-auto">
          <h1 className="text-3xl font-bold text-center text-blue-600 mb-6">
            Información de la Bodega: {bodega?.nombreBodega}
          </h1>

          <div className="grid grid-cols-1 md:grid-cols-2 gap-4 mb-8">
            <div>
              <p>
                <strong>Creador:</strong> {bodega?.creador}
              </p>
              <p>
                <strong>Bodeguero Asignado:</strong> {bodega?.bodegueroAsignado}
              </p>
              <p>
                <strong>Fecha de Creación:</strong> {bodega?.fechaDeCreacion}
              </p>
            </div>
          </div>

          <h2 className="text-xl font-semibold text-gray-700 mb-4">
            Herramientas
          </h2>

          <div className="overflow-auto mb-6">
            <table className="min-w-full border border-gray-300">
              <thead className="bg-blue-200 text-gray-700">
                <tr>
                  <th className="p-2 border">Imagen</th>
                  <th className="p-2 border">Nombre</th>
                  <th className="p-2 border">Código</th>
                  <th className="p-2 border">Modelo</th>
                  <th className="p-2 border">Ubicación</th>
                  <th className="p-2 border">Estado</th>
                  <th className="p-2 border">Calibracion</th>
                </tr>
              </thead>
              <tbody>
                {bodega?.herramientas.map((h, i) => (
                  <tr key={i} className="text-sm text-center">
                    <td className="p-2 border">
                      <a
                        href={h.imagen}
                        target="_blank"
                        rel="noopener noreferrer"
                      >
                        Ver archivo
                      </a>
                    </td>
                    <td className="p-2 border">{h.nombre}</td>
                    <td className="p-2 border">{h.codigo}</td>
                    <td className="p-2 border">{h.modelo}</td>
                    <td className="p-2 border">{h.ubicacion}</td>
                    <td className="p-2 border">{h.estado}</td>
                    <td className="p-2 border">{h.calibracion}</td>
                  </tr>
                ))}
              </tbody>
            </table>
          </div>

          <div className="flex gap-4 justify-end">
            <button
              onClick={exportToExcel}
              className="px-4 py-2 bg-green-600 text-white rounded hover:bg-green-700"
            >
              Exportar a Excel
            </button>
            <button
              onClick={exportToPDF}
              className="px-4 py-2 bg-red-600 text-white rounded hover:bg-red-700"
            >
              Exportar a PDF
            </button>
          </div>

          {/* Exportador Excel oculto */}
          <ExcelExport
            data={bodega?.herramientas || []}
            ref={excelExporter}
            fileName="Inventario_Herramientas.xlsx"
          >
            <ExcelExportColumn field="codigo" title="Código" />
            <ExcelExportColumn field="estado" title="Estado" />
            <ExcelExportColumn field="nombre" title="Nombre" />
            <ExcelExportColumn field="NParte" title="N° Parte" />
            <ExcelExportColumn field="serie" title="Serie" />
            <ExcelExportColumn field="modelo" title="Modelo" />
            <ExcelExportColumn field="marca" title="Marca" />
            <ExcelExportColumn field="ubicacion" title="Ubicación" />
            <ExcelExportColumn field="cantidad" title="Cantidad" />
            <ExcelExportColumn field="observacion" title="Observación" />
          </ExcelExport>
        </div>
      </div>
    </div>
  );
};

export default InformacionBodega;



================================================
FILE: pages/calibracion/index.tsx
================================================
import Router from "next/router";
import { useState, useEffect } from "react";
import { Button } from "react-bootstrap";
import { toast } from "react-toastify";
import { useAuth } from "../../controllers/hooks/use_auth";
import { CheckPermissions } from "../../controllers/utils/check_permissions";
import HttpClient from "../../controllers/utils/http_client";
import { Calibracion, Solicitude } from "../../models";
import Sidebar from "../components/sidebar";
import TreeTable, { ColumnData } from "../components/tree_table";

type Props = {
  dates: Array<string>;
  sm?: number;
  md?: number;
  lg?: number;
  xl?: number;
  inTabs?: boolean;
};

export const CalibracionPage = (props: Props) => {
  const { auth } = useAuth();
  const [tableData, setTableData] = useState<Array<Calibracion>>([]);
  const [loading, setLoading] = useState<boolean>(true);

  const loadData = async () => {
    setLoading(true);

    var response = await HttpClient(
      "/api/calibracion",
      "GET",
      auth.usuario,
      auth.rol
    );

    const calibracion: Array<Calibracion> = response.data ?? [];
    console.log(calibracion);
    setTableData(calibracion);
    setLoading(false);
  };

  useEffect(() => {
    loadData();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  const columns: ColumnData[] = [
    {
      dataField: "number",
      caption: "#",
      alignment: "center",
      cssClass: "bold",
    },
    {
      dataField: "solicitante",
      caption: "Solicitante",
      alignment: "center",
      cssClass: "bold",
    },
    {
      dataField: "fecha",
      caption: "Fecha",
      alignment: "center",
      cssClass: "bold",
    },
    {
      dataField: "estado",
      caption: "Estado",
      alignment: "center",
      cssClass: "bold",
    },
  ];

  const buttons = {
    edit: (rowData: Calibracion) => {
      // Verificar si las herramientas ya fueron entregadas
      if (rowData.estado?.toLowerCase() === "herramientas calibradas") {
        toast.error(
          "No puedes editar una solicitud con herramientas calibradas"
        );
        return;
      }

      // Verificar permisos del usuario
      if (!CheckPermissions(auth, [0, 1, 2])) {
        toast.error("No tienes permisos para editar esta solicitud");
        return;
      }

      // Redireccionar a la edición si pasa ambas validaciones
      Router.push({
        pathname: "/calibracion/edit/" + (rowData.id as string),
      });
    },
  };
  return (
    <>
      <div className="flex h-screen">
        <div className="md:w-1/6 max-w-none">
          <Sidebar />
        </div>
        <div className="w-12/12 md:w-5/6 bg-blue-100">
          <div className="bg-white w-5/6 h-5/6 mx-auto">
            <div className="mt-6">
              <p className="md:text-4xl text-xl text-center pt-5 font-extrabold text-blue-500">
                Registro de herramientas calibradas
              </p>
            </div>
            {CheckPermissions(auth, [0, 1]) && (
              <Button
                className="text-white bg-blue-400 hover:bg-blue-500 focus:outline-none focus:ring-4 focus:ring-blue-300 font-medium rounded-full text-sm px-5 py-3 text-center mx-2 mb-2 mt-3 dark:focus:ring-blue-900"
                onClick={() =>
                  CheckPermissions(auth, [0, 1])
                    ? Router.push({ pathname: "/calibracion/create" })
                    : toast.info("No puede ingresar solicitudes")
                }
              >
                Crear registro
              </Button>
            )}

            <div className="p-2">
              <TreeTable
                keyExpr="id"
                dataSource={tableData}
                columns={columns}
                searchPanel={true}
                buttons={buttons}
                colors={{ headerBackground: "#F8F9F9", headerColor: "#466cf2" }}
                buttonsFirst
                paging
                showNavigationButtons
                showNavigationInfo
                pageSize={10}
                infoText={(actual, total, items) =>
                  `Página ${actual} de ${total} (${items} solicitudes de calibracion)`
                }
              />
            </div>
          </div>
        </div>
      </div>
    </>
  );
};

export default CalibracionPage;



================================================
FILE: pages/calibracion/create/index.tsx
================================================
/* eslint-disable react/no-unescaped-entities */
import { Button } from "react-bootstrap";
import Sidebar from "../../components/sidebar";
import { useAuth } from "../../../controllers/hooks/use_auth";
import { useFormik } from "formik";
import Router from "next/router";
import { toast } from "react-toastify";
import {
  Calibracion,
  Herramienta,
  ResponseData,
  Usuario,
} from "../../../models";
import HttpClient from "../../../controllers/utils/http_client";
import { useEffect, useState } from "react";
import FormatedDate from "../../../controllers/utils/formated_date";
import Select from "react-select";

export const RegistroCreate = () => {
  const { auth } = useAuth();
  const [loading, setLoading] = useState(false);
  const [herramientas, setHerramientas] = useState<Herramienta[]>([]);
  const [client, setClient] = useState<Usuario[]>([]);
  const [selectedTool, setSelectedTool] = useState(null);

  // Cargar herramientas disponibles
  const loadProducts = async () => {
    setLoading(true);

    const response = await HttpClient(
      "/api/bodegas",
      "GET",
      auth.usuario,
      auth.rol
    );

    const bodegas = response.data ?? [];
    console.log("bodegas disponibles:", bodegas);
    const bodegasDelUsuario =
      auth.rol === 0
        ? bodegas
        : bodegas.filter(
            (bodega) =>
              bodega.bodegueroAsignado.toLowerCase() ===
              auth.usuario.toLowerCase()
          );

    // Extraemos todas las herramientas de todas las bodegas
    const herramientasDisponibles = bodegasDelUsuario
      .flatMap((bodega) => bodega.herramientas ?? []) // Aseguramos que herramientas exista
      .filter(
        (herramienta) =>
          herramienta.estado === "Disponible" &&
          herramienta.calibracion !== "En calibracion"
      );

    console.log("Herramientas disponibles:", herramientasDisponibles);
    setHerramientas(herramientasDisponibles);

    setLoading(false);
  };

  // Cargar herramientas disponibles
  const loadClient = async () => {
    setLoading(true);

    const response = await HttpClient(
      "/api/user",
      "GET",
      auth.usuario,
      auth.rol
    );

    console.log(response.data);
    const clientesDisponibles = (response.data ?? []).filter(
      (clientes: any) => clientes.rol === 2
    );

    console.log("clientes clientesDisponibles:", clientesDisponibles);
    setClient(clientesDisponibles);

    setLoading(false);
  };

  useEffect(() => {
    loadProducts();
    loadClient();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  // Valores iniciales para la solicitud
  const initialValues: Calibracion = {
    number: 0, // Generar un número si es necesario
    herramientas: [],
    fecha: FormatedDate(), // Fecha formateada
    solicitante: auth?.nombre || "",
    estado: "En calibracion",
  };

  // Configuración de Formik
  const formik = useFormik({
    initialValues,
    onSubmit: async (values) => {
      if (values.herramientas.length === 0) {
        toast.warning("Debes agregar al menos una herramienta.");
        return;
      }

      // Si pasa las validaciones, se envía el formulario
      setLoading(true);
      console.log("Valores del formulario:", values);

      const response = await HttpClient(
        "/api/calibracion",
        "POST",
        auth.usuario,
        auth.rol,
        values
      );

      if (response.success) {
        console.log(values.herramientas);

        try {
          // 1. Obtener todas las bodegas para identificar dónde está cada herramienta
          const bodegasResponse = await HttpClient(
            "/api/bodegas",
            "GET",
            auth.usuario,
            auth.rol
          );

          const bodegas = bodegasResponse.data ?? [];

          // 2. Crear un mapa de herramientas a actualizar por bodega
          const actualizacionesPorBodega = {};

          // Agrupar herramientas por bodega
          for (const herramientaSolicitud of values.herramientas) {
            // Buscar la bodega que contiene esta herramienta
            for (const bodega of bodegas) {
              if (!bodega.herramientas) continue;

              const indiceHerramienta = bodega.herramientas.findIndex(
                (h) => h.id === herramientaSolicitud.id
              );

              if (indiceHerramienta !== -1) {
                // Esta herramienta está en esta bodega
                if (!actualizacionesPorBodega[bodega.id]) {
                  // Inicializar la entrada para esta bodega si no existe
                  actualizacionesPorBodega[bodega.id] = {
                    bodega: bodega,
                    herramientasActualizar: [],
                  };
                }

                // Agregar esta herramienta a la lista de actualizaciones
                actualizacionesPorBodega[bodega.id].herramientasActualizar.push(
                  {
                    indice: indiceHerramienta,
                    id: herramientaSolicitud.id,
                  }
                );

                // No es necesario seguir buscando en otras bodegas
                break;
              }
            }
          }

          // 3. Realizar las actualizaciones por bodega
          await Promise.all(
            Object.values(actualizacionesPorBodega).map(
              async (actualizacion) => {
                //@ts-ignore
                const { bodega, herramientasActualizar } = actualizacion;

                // Crear una copia de las herramientas de la bodega
                const herramientasActualizadas = [...bodega.herramientas];

                // Actualizar cada herramienta
                for (const { indice, id } of herramientasActualizar) {
                  herramientasActualizadas[indice] = {
                    ...herramientasActualizadas[indice],
                    calibracion: "En calibracion",
                  };
                }

                // Crear la bodega actualizada
                const bodegaActualizada = {
                  ...bodega,
                  herramientas: herramientasActualizadas,
                };

                // Enviar la actualización al servidor
                return HttpClient(
                  `/api/bodegas/`,
                  "PUT",
                  auth.usuario,
                  auth.rol,
                  bodegaActualizada
                );
              }
            )
          );

          toast.success(
            "Registro creado correctamente y herramientas actualizadas a 'En calibracion'!"
          );
        } catch (error) {
          console.error("Error al actualizar las herramientas:", error);
          toast.warning(
            "Registro creado pero hubo un problema al actualizar las herramientas."
          );
        }

        Router.back();
      } else {
        toast.warning(response.message);
      }

      setLoading(false);
    },
  });

  // Filtrar herramientas ya seleccionadas
  const herramientasDisponibles = herramientas.filter(
    (h) => !formik.values.herramientas.some((selected) => selected.id === h.id)
  );

  // Opciones para el Select con búsqueda
  const toolOptions = herramientasDisponibles.map((tool) => ({
    value: tool.id,
    label: `${tool.nombre} - ${tool.codigo} - ${tool.modelo} - ${tool.marca} - ${tool.ubicacion} - ${tool.serie}`,
  }));

  // Agregar herramienta
  const addHerramienta = () => {
    if (!selectedTool) return;
    const selectedToolData = herramientas.find(
      (tool) => tool.id === selectedTool.value
    );
    if (selectedToolData) {
      formik.setFieldValue("herramientas", [
        ...formik.values.herramientas,
        selectedToolData,
      ]);
      setSelectedTool(null);
    }
  };

  return (
    <div className="flex h-screen">
      <div className="md:w-1/6 max-w-none">
        <Sidebar />
      </div>
      <div className="w-12/12 md:w-5/6 bg-blue-100 p-4">
        <div className="bg-white w-5/6 mx-auto p-6 m-5 rounded-lg shadow-md">
          <h1 className="text-3xl font-bold text-blue-500 text-center mb-4">
            Crear registro de herramientas para calibrar
          </h1>
          <form onSubmit={formik.handleSubmit}>
            {/* Datos del cliente */}
            <div className="mb-4">
              <label className="block text-blue-500 font-bold mb-2">
                Solicitante
              </label>
              <input
                type="text"
                name="solicitante"
                onChange={formik.handleChange}
                value={formik.values.solicitante}
                className="border p-2 w-full rounded-lg"
                placeholder="Nombre del solicitante"
                disabled
              />
            </div>
            <div className="mb-4">
              <label className="block text-blue-500 font-bold mb-2">
                Fecha
              </label>
              <input
                type="text"
                name="fecha"
                value={formik.values.fecha}
                disabled
                className="border p-2 w-full bg-gray-200 rounded-lg"
              />
            </div>

            {/* Agregar herramientas */}
            <div className="mb-4">
              <p className="text-xl font-bold text-blue-500 mb-2">
                Agregar Herramientas
              </p>
              <div className="flex items-center gap-2">
                <div className="w-full">
                  <Select
                    value={selectedTool}
                    onChange={setSelectedTool}
                    options={toolOptions}
                    isSearchable
                    placeholder="Buscar herramienta..."
                    className="w-full"
                  />
                </div>
                <Button
                  className="bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded-lg"
                  type="button"
                  onClick={addHerramienta}
                >
                  Agregar
                </Button>
              </div>
            </div>

            {/* Listado de herramientas agregadas */}
            <div className="mb-4">
              <p className="text-xl font-bold text-blue-500 mb-2">
                Herramientas agregadas
              </p>
              {formik.values.herramientas.length === 0 ? (
                <p className="text-gray-500">No hay herramientas agregadas.</p>
              ) : (
                <ul className="border rounded-lg p-3 bg-gray-50">
                  {formik.values.herramientas.map((tool, index) => (
                    <li
                      key={index}
                      className="flex justify-between items-center border-b last:border-b-0 p-2"
                    >
                      <span>
                        {tool.nombre} - {tool.codigo} - ${tool.modelo} - $
                        {tool.marca} - ${tool.ubicacion} - ${tool.serie}
                      </span>
                      <Button
                        className="bg-red-500 hover:bg-red-600 text-white font-bold py-1 px-3 rounded-lg"
                        size="sm"
                        onClick={() => {
                          const updatedTools =
                            formik.values.herramientas.filter(
                              (_, i) => i !== index
                            );
                          formik.setFieldValue("herramientas", updatedTools);
                        }}
                      >
                        Eliminar
                      </Button>
                    </li>
                  ))}
                </ul>
              )}
            </div>

            <Button
              type="submit"
              disabled={loading}
              className="bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-4 rounded-lg w-full"
            >
              {loading ? "Enviando..." : "Enviar Registro"}
            </Button>
          </form>
        </div>
      </div>
    </div>
  );
};

export default RegistroCreate;



================================================
FILE: pages/calibracion/edit/[id].tsx
================================================
/* eslint-disable react/no-unescaped-entities */
import { Button } from "react-bootstrap";
import Sidebar from "../../components/sidebar";
import { useAuth } from "../../../controllers/hooks/use_auth";
import { useFormik } from "formik";
import Router from "next/router";
import { toast } from "react-toastify";
import { Calibracion, ResponseData } from "../../../models";
import HttpClient from "../../../controllers/utils/http_client";
import { useEffect, useState } from "react";

export const EditarCalibracion = () => {
  const { auth } = useAuth();
  const [loading, setLoading] = useState(false);
  const [solicitudes, setsolicitudes] = useState<Calibracion[]>([]);
  const [initialValues, setInitialValues] = useState<Calibracion | null>(null);

  const loadData = async () => {
    setLoading(true);
    const solicitudeId = Router.query.id as string;
    const response = await HttpClient(
      `/api/calibracion/${solicitudeId}`,
      "GET",
      auth.usuario,
      auth.rol
    );

    console.log("response.data:", response.data);
    setsolicitudes(response.data);
    setInitialValues(response.data);

    setLoading(false);
  };

  useEffect(() => {
    loadData();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  // Valores iniciales para la solicitud

  // Configuración de Formik
  const formik = useFormik({
    enableReinitialize: true,
    initialValues: initialValues || {
      number: 0, // Generar un número si es necesario
      herramientas: [],
      fecha: "",
      solicitante: "",
      receptor: "",
      estado: "",
    },
    onSubmit: async (values) => {
      // Si pasa las validaciones, se envía el formulario
      setLoading(true);
      console.log("Valores del formulario:", values);
      values.estado = "Herramientas calibradas";
      const response: ResponseData = await HttpClient(
        `/api/calibracion`,
        "PUT",
        auth.usuario,
        auth.rol,
        values
      );

      if (response.success) {
        try {
          // 1. Obtener todas las bodegas para identificar dónde está cada herramienta
          const bodegasResponse = await HttpClient(
            "/api/bodegas",
            "GET",
            auth.usuario,
            auth.rol
          );

          const bodegas = bodegasResponse.data ?? [];

          // 2. Crear un mapa de herramientas a actualizar por bodega
          const actualizacionesPorBodega = {};

          // Agrupar herramientas por bodega
          for (const herramientaSolicitud of values.herramientas) {
            // Buscar la bodega que contiene esta herramienta
            for (const bodega of bodegas) {
              if (!bodega.herramientas) continue;

              const indiceHerramienta = bodega.herramientas.findIndex(
                (h) => h.id === herramientaSolicitud.id
              );

              if (indiceHerramienta !== -1) {
                // Esta herramienta está en esta bodega
                if (!actualizacionesPorBodega[bodega.id]) {
                  // Inicializar la entrada para esta bodega si no existe
                  actualizacionesPorBodega[bodega.id] = {
                    bodega: bodega,
                    herramientasActualizar: [],
                  };
                }

                // Agregar esta herramienta a la lista de actualizaciones
                actualizacionesPorBodega[bodega.id].herramientasActualizar.push(
                  {
                    indice: indiceHerramienta,
                    id: herramientaSolicitud.id,
                  }
                );

                // No es necesario seguir buscando en otras bodegas
                break;
              }
            }
          }

          // 3. Realizar las actualizaciones por bodega
          await Promise.all(
            Object.values(actualizacionesPorBodega).map(
              async (actualizacion) => {
                //@ts-ignore
                const { bodega, herramientasActualizar } = actualizacion;

                // Crear una copia de las herramientas de la bodega
                const herramientasActualizadas = [...bodega.herramientas];

                // Actualizar cada herramienta
                for (const { indice, id } of herramientasActualizar) {
                  herramientasActualizadas[indice] = {
                    ...herramientasActualizadas[indice],
                    calibracion: "Calibrada",
                  };
                }

                // Crear la bodega actualizada
                const bodegaActualizada = {
                  ...bodega,
                  herramientas: herramientasActualizadas,
                };

                // Enviar la actualización al servidor
                return HttpClient(
                  `/api/bodegas/`,
                  "PUT",
                  auth.usuario,
                  auth.rol,
                  bodegaActualizada
                );
              }
            )
          );

          toast.success(
            "Registro creado correctamente y herramientas actualizadas a 'Calibrada'!"
          );
          Router.back();
        } catch (error) {
          console.error("Error al actualizar las herramientas:", error);
          toast.warning(
            "Registro creado pero hubo un problema al actualizar las herramientas."
          );
        }
      } else {
        toast.warning(response.message);
      }

      //const response: ResponseData = await HttpClient(
      //  "/api/solicitudes",
      //  "POST",
      //  auth.usuario,
      //  auth.rol,
      //  values
      //);
      //
      //if (response.success) {
      //  toast.success("Registro creado correctamente!");
      //
      //} else {
      //  toast.warning(response.message);
      //}

      setLoading(false);
    },
  });

  return (
    <div className="flex h-screen">
      <div className="md:w-1/6 max-w-none">
        <Sidebar />
      </div>
      <div className="w-12/12 md:w-5/6 bg-blue-100 p-4">
        <div className="bg-white w-5/6 mx-auto p-6 m-5 rounded-lg shadow-md">
          <h1 className="text-3xl font-bold text-blue-500 text-center mb-4">
            Editar registro de herramientas prestadas
          </h1>
          <form onSubmit={formik.handleSubmit}>
            {/* Datos del cliente */}
            <div className="mb-4">
              <label className="block text-blue-500 font-bold mb-2">
                Solicitante
              </label>
              <input
                type="text"
                name="solicitante"
                onChange={formik.handleChange}
                value={formik.values.solicitante}
                className="border p-2 w-full rounded-lg"
                placeholder="Nombre del solicitante"
                disabled
              />
            </div>
            <div className="mb-4">
              <label className="block text-blue-500 font-bold mb-2">
                Fecha
              </label>
              <input
                type="text"
                name="fecha"
                value={formik.values.fecha}
                disabled
                className="border p-2 w-full bg-gray-200 rounded-lg"
              />
            </div>

            {/* Listado de herramientas agregadas */}
            <div className="mb-4">
              <p className="text-xl font-bold text-blue-500 mb-2">
                Herramientas agregadas para calibrar
              </p>
              {formik.values.herramientas.length === 0 ? (
                <p className="text-gray-500">No hay herramientas agregadas.</p>
              ) : (
                <ul className="border rounded-lg p-3 bg-gray-50">
                  {formik.values.herramientas.map((tool, index) => (
                    <li
                      key={index}
                      className="flex justify-between items-center border-b last:border-b-0 p-2"
                    >
                      <span>
                        {tool.nombre} - {tool.codigo} - {tool.modelo} -
                        {tool.marca} - {tool.ubicacion} - {tool.serie}
                      </span>
                    </li>
                  ))}
                </ul>
              )}
            </div>

            <Button
              type="submit"
              disabled={loading}
              className="bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-4 rounded-lg w-full"
            >
              {loading ? "Registrando..." : "Registrar herramientas calibradas"}
            </Button>
          </form>
        </div>
      </div>
    </div>
  );
};

export default EditarCalibracion;



================================================
FILE: pages/components/pdf_container.tsx
================================================
import styled from 'styled-components'

const PdfContainer = styled.div`
@page {
  size: 297mm 210mm;
}

@media all {
  .pagebreak {
    display: none;
  }
}

@media print {
  .pagebreak {
    page-break-before: always;
  }
}
`

export default PdfContainer


================================================
FILE: pages/components/sidebar.tsx
================================================
/* eslint-disable @next/next/no-html-link-for-pages */
import {
  MdOutlineSpaceDashboard,
  MdOutlineSettings,
  MdOutlineLogout,
  MdPets,
  MdPeople,
  MdStore,
  MdAttachMoney,
  MdMedicalServices,
  MdProductionQuantityLimits,
  MdOutlineStickyNote2,
  MdMedicalInformation,
} from "react-icons/md";
import { GiHamburgerMenu } from "react-icons/gi";
import { useAuth } from "../../controllers/hooks/use_auth";
import { useCallback, useState } from "react";
import Router, { useRouter } from "next/router";
import Link from "next/link";
import { CheckPermissions } from "../../controllers/utils/check_permissions";

const Sidebar = () => {
  const { auth, logout } = useAuth();
  const [mostrarCarga, setMostrarCarga] = useState(false);
  const router = useRouter();

  const handleLogout = useCallback(() => {
    logout();
    Router.push("/");
  }, [logout]);

  const handleChanges = () => {
    setMostrarCarga(true);
    Router.push("/configuration");
    setTimeout(() => {
      setMostrarCarga(false);
    }, 10000);
  };

  const isActive = (path: string) => router.pathname === path;

  return (
    <div className="p-6 w-1/2 h-screen bg-white z-20 fixed top-0 left-0 lg:w-1/6">
      <p className="text-center mb-4">
        Usuario: <strong>{auth?.nombre}</strong>
      </p>
      <div className="flex flex-col justify-start">
        <h1 className="text-center font-bold text-xl mb-2">Menu</h1>
        <a
          href="/"
          className={`flex items-center gap-4 mb-2 px-5 py-2 rounded-lg hover:bg-blue-500 hover:text-white ${
            isActive("/") ? "bg-blue-500 text-white" : "text-gray-800"
          }`}
          onClick={handleChanges}
        >
          <MdOutlineSpaceDashboard className="text-2xl" />
          <span>Inicio</span>
        </a>
        <>
          <a
            href="/solicitudes"
            className={`flex items-center gap-4 mb-2 px-5 py-2 rounded-lg hover:bg-blue-500 hover:text-white ${
              isActive("/solicitudes")
                ? "bg-blue-500 text-white"
                : "text-gray-800"
            }`}
            onClick={handleChanges}
          >
            <MdStore className="text-2xl" />
            <span>Solicitudes</span>
          </a>
        </>
        {!CheckPermissions(auth, [2]) && (
          <a
            href="/bodegas"
            className={`flex items-center gap-4 mb-2 px-5 py-2 rounded-lg hover:bg-blue-500 hover:text-white ${
              isActive("/bodegas") ? "bg-blue-500 text-white" : "text-gray-800"
            }`}
            onClick={handleChanges}
          >
            <MdProductionQuantityLimits className="text-2xl" />
            <span>Bodegas</span>
          </a>
        )}
        {!CheckPermissions(auth, [2]) && (
          <a
            href="/calibracion"
            className={`flex items-center gap-4 mb-2 px-5 py-2 rounded-lg hover:bg-blue-500 hover:text-white ${
              isActive("/configuration")
                ? "bg-blue-500 text-white"
                : "text-gray-800"
            }`}
            onClick={handleChanges}
          >
            <MdMedicalInformation className="text-2xl" />
            <span>Calibración</span>
          </a>
        )}
        {!CheckPermissions(auth, [1, 2]) && (
          <a
            href="/configuration"
            className={`flex items-center gap-4 mb-2 px-5 py-2 rounded-lg hover:bg-blue-500 hover:text-white ${
              isActive("/configuration")
                ? "bg-blue-500 text-white"
                : "text-gray-800"
            }`}
            onClick={handleChanges}
          >
            <MdOutlineSettings className="text-2xl" />
            <span>Administración</span>
          </a>
        )}
        {!CheckPermissions(auth, [1, 2]) && (
          <a
            href="/auditory"
            className={`flex items-center gap-4 mb-2 px-5 py-2 rounded-lg hover:bg-blue-500 hover:text-white ${
              isActive("/auditory") ? "bg-blue-500 text-white" : "text-gray-800"
            }`}
            onClick={handleChanges}
          >
            <MdOutlineStickyNote2 className="text-2xl" />
            <span>Auditorias</span>
          </a>
        )}
        <button
          onClick={handleLogout}
          className="flex items-center gap-4 px-5 py-2 mt-4 rounded-lg hover:bg-blue-500 hover:text-white text-gray-800"
        >
          <MdOutlineLogout className="text-2xl" />
          <span>Cerrar Sesión</span>
        </button>
      </div>
    </div>
  );
};

export default Sidebar;



================================================
FILE: pages/components/toastify.tsx
================================================
import { ToastContainer as Container } from "react-toastify";

 const ToastContainer = () => {
  return (
    <Container
      position="top-right"
      autoClose={5000}
      hideProgressBar={true}
      closeOnClick={false}
      pauseOnHover={false}
      draggable={false}
    />
  );
};

export default ToastContainer



================================================
FILE: pages/components/loading_container/index.tsx
================================================
import Image from "next/image";
import { useEffect, useState } from "react";
import GifContainer from "./style";

type Props = {
  visible: boolean;
  children: React.ReactNode;
  miniVersion?: boolean;
};

const LoadingContainer = (props: Props): JSX.Element => {
  const { visible, children, miniVersion } = props;
  const [loading, setVisibility] = useState<boolean>(visible);

  useEffect(() => {
    setVisibility(visible);
  }, [visible]);

  return loading ? (
    <GifContainer miniVersion={miniVersion}>
      <Image
        src="/loadingCard.gif"
        alt="loading-gif"
        width="300"
        height="300"
        priority={false}
      />
    </GifContainer>
  ) : (
    <>{children}</>
  );
};

export default LoadingContainer;



================================================
FILE: pages/components/loading_container/style.tsx
================================================
import styled from "styled-components";

type GifContainerProps = {
  miniVersion?: boolean;
};

 const GifContainer = styled.div`
  display: flex;
  justify-content: center;
  align-items: center;
  padding-top: ${(props: GifContainerProps) => {
    if (props.miniVersion) return "5%";
    else return "10em";
  }};
`;

export default GifContainer



================================================
FILE: pages/components/modals/confirm.tsx
================================================
import { Button, Modal } from "react-bootstrap";
import { ModalProps } from "../../../models";

const ConfirmModal = (props: ModalProps<any>) => {
  return (
    <div
      className={`fixed inset-0 flex items-center justify-center z-50 ${
        props.visible ? "" : "hidden"
      }`}
    >
      <div className="fixed inset-0 bg-black opacity-50"></div>
      <div className="bg-white p-6 rounded shadow-lg z-10 w-1/3 h-1/6 overflow-y-auto">
        <Modal.Header className="text-lg font-semibold">
          <Modal.Title>
            ¿Está seguro de querer borrar este elemento?
          </Modal.Title>
        </Modal.Header>

        <hr />
        <div className="justify-end mt-3 grid md:grid-cols-4 grid-cols-1 gap-4">
          <div>
            <button
              className="bg-transparent hover:bg-blue-500 text-blue-700 font-semibold hover:text-white py-2 px-4 border border-blue-500 hover:border-transparent rounded-full text-sm"
              onClick={props.onDone}
            >
              Borrar
            </button>
          </div>
          <div className="md:col-end-4">
            <button
              className="bg-transparent hover:bg-gray-500 text-gray-700 font-semibold hover:text-white py-2 px-4 border border-gray-500 hover:border-transparent rounded-full text-sm"
              onClick={props.close}
            >
              Cancelar
            </button>
          </div>
        </div>
      </div>
    </div>
  );
};

export default ConfirmModal;



================================================
FILE: pages/components/modals/modalModelos.tsx
================================================
import { useFormik } from "formik";
import React, { useEffect, useState } from "react";
import { ModalProps, ModelosHerramienta } from "../../../models";
import { toast } from "react-toastify";
import { useAuth } from "../../../controllers/hooks/use_auth";
import theme from "../../../controllers/styles/theme";

const initialUser: ModelosHerramienta = {
  id: null,
  nombre: "",
};

interface Props extends ModalProps<ModelosHerramienta> {
  initialData?: ModelosHerramienta;
}

const ModalModelos = (props: Props) => {
  const { auth } = useAuth();
  const [loading, setLoading] = useState<boolean>(false);
  const [initialValues, setInitialValues] = useState<ModelosHerramienta>(initialUser);

  const handleClose = () => {
    formik.resetForm({ values: initialUser });
    props.close();
  };

  // maneja los datos y comportamiento del formulario
  const formik = useFormik({
    enableReinitialize: true,
    validateOnMount: true,
    validateOnBlur: true,
    validateOnChange: true,
    initialValues,
    onSubmit: async (formData: ModelosHerramienta) => {
      if (formData.nombre === "") {
        toast.warning("El nombre del modelo no puede estar vacio");
        return;
      }

      setLoading(true);
      console.log(formData);
      await props.onDone(formData);
      setLoading(false);
      handleClose();
    },
  });

  useEffect(() => {
    if (props.initialData) setInitialValues(props.initialData);
  }, [props.initialData]);

  return (
    <>
      <div
        className={`fixed inset-0 flex items-center justify-center z-50 ${
          props.visible ? "" : "hidden"
        }`}
      >
        <div className="fixed inset-0 bg-black opacity-50"></div>
        <div className="bg-white p-6 rounded shadow-lg z-10 w-2/3 h-5/6 overflow-y-auto">
          <form onSubmit={formik.handleSubmit}>
            <div
              style={{ color: theme.colors.blue }}
              className="text-center text-xl mb-2 font-semibold"
            >
              Crear/Editar modelo
            </div>
            <hr />
            <div className="grid md:grid-cols-2 grid-cols-1 gap-4 mb-3">
              <div>
                <label className="text-gray-700 text-sm font-bold mb-2">
                  Nombre del modelo
                </label>

                <input
                  className="appearance-none border-2 border-gray-200 rounded w-full py-2 px-4 text-gray-700 leading-tight focus:outline-none focus:bg-white focus:border-purple-500"
                  type="text"
                  placeholder="Nombre del modelo"
                  name="nombre"
                  onChange={formik.handleChange}
                  value={formik.values.nombre}
                />
              </div>
            </div>
            <hr />
            <button
              className="bg-transparent hover:bg-blue-500 text-blue-700 font-semibold hover:text-white py-2 px-4 border border-blue-500 hover:border-transparent rounded mb-4"
              type="submit"
            >
              Guardar
            </button>
          </form>
          <button
            className="bg-transparent hover:bg-gray-500 text-gray-700 font-semibold hover:text-white py-2 px-4 border border-gray-500 hover:border-transparent rounded"
            onClick={handleClose}
          >
            Cancelar
          </button>
        </div>
      </div>
    </>
  );
};
export default ModalModelos;



================================================
FILE: pages/components/modals/modalUbicaciones.tsx
================================================
import { useFormik } from "formik";
import React, { useEffect, useState } from "react";
import { ModalProps, Ubicaciones } from "../../../models";
import { toast } from "react-toastify";
import { useAuth } from "../../../controllers/hooks/use_auth";
import theme from "../../../controllers/styles/theme";

const initialUser: Ubicaciones = {
  id: null,
  nombre: "",
};

interface Props extends ModalProps<Ubicaciones> {
  initialData?: Ubicaciones;
}

const UbicacionesModal = (props: Props) => {
  const { auth } = useAuth();
  const [loading, setLoading] = useState<boolean>(false);
  const [initialValues, setInitialValues] = useState<Ubicaciones>(initialUser);

  const handleClose = () => {
    formik.resetForm({ values: initialUser });
    props.close();
  };

  // maneja los datos y comportamiento del formulario
  const formik = useFormik({
    enableReinitialize: true,
    validateOnMount: true,
    validateOnBlur: true,
    validateOnChange: true,
    initialValues,
    onSubmit: async (formData: Ubicaciones) => {
      if (formData.nombre === "") {
        toast.warning("El nombre de la ubicacion no puede estar vacio");
        return;
      }

      setLoading(true);
      console.log(formData);
      await props.onDone(formData);
      setLoading(false);
      handleClose();
    },
  });

  useEffect(() => {
    if (props.initialData) setInitialValues(props.initialData);
  }, [props.initialData]);

  return (
    <>
      <div
        className={`fixed inset-0 flex items-center justify-center z-50 ${
          props.visible ? "" : "hidden"
        }`}
      >
        <div className="fixed inset-0 bg-black opacity-50"></div>
        <div className="bg-white p-6 rounded shadow-lg z-10 w-2/3 h-5/6 overflow-y-auto">
          <form onSubmit={formik.handleSubmit}>
            <div
              style={{ color: theme.colors.blue }}
              className="text-center text-xl mb-2 font-semibold"
            >
              Crear/Editar ubicacion
            </div>
            <hr />
            <div className="grid md:grid-cols-2 grid-cols-1 gap-4 mb-3">
              <div>
                <label className="text-gray-700 text-sm font-bold mb-2">
                  Nombre de la ubicacion
                </label>

                <input
                  className="appearance-none border-2 border-gray-200 rounded w-full py-2 px-4 text-gray-700 leading-tight focus:outline-none focus:bg-white focus:border-purple-500"
                  type="text"
                  placeholder="Nombre de la ubicacion"
                  name="nombre"
                  onChange={formik.handleChange}
                  value={formik.values.nombre}
                />
              </div>
            </div>
            <hr />
            <button
              className="bg-transparent hover:bg-blue-500 text-blue-700 font-semibold hover:text-white py-2 px-4 border border-blue-500 hover:border-transparent rounded mb-4"
              type="submit"
            >
              Guardar
            </button>
          </form>
          <button
            className="bg-transparent hover:bg-gray-500 text-gray-700 font-semibold hover:text-white py-2 px-4 border border-gray-500 hover:border-transparent rounded"
            onClick={handleClose}
          >
            Cancelar
          </button>
        </div>
      </div>
    </>
  );
};
export default UbicacionesModal;



================================================
FILE: pages/components/modals/user.tsx
================================================
import { useFormik } from "formik";
import React, { useEffect, useState } from "react";
import { Usuario, ModalProps } from "../../../models";
import { toast } from "react-toastify";
import { useAuth } from "../../../controllers/hooks/use_auth";
import theme from "../../../controllers/styles/theme";
import HttpClient from "../../../controllers/utils/http_client";

const initialUser: Usuario = {
  id: null,
  number: 0,
  usuario: "",
  contraseña: "",
  correo: "",
  telefono: "",
  rol: 1,
  nombre: "",
  identificacion: "",
  estado: "",
};

interface Props extends ModalProps<Usuario> {
  initialData?: Usuario;
}

const UserModal = (props: Props) => {
  const { auth } = useAuth();
  const [loading, setLoading] = useState<boolean>(false);
  const [initialValues, setInitialValues] = useState<Usuario>(initialUser);

  const handleClose = () => {
    formik.resetForm({ values: initialUser });
    props.close();
  };

  // maneja los datos y comportamiento del formulario
  const formik = useFormik({
    enableReinitialize: true,
    validateOnMount: true,
    validateOnBlur: true,
    validateOnChange: true,
    initialValues,
    onSubmit: async (formData: Usuario) => {
      if (formData.nombre === "") {
        toast.warning("El nombre del traabajador no puede estar vacio");
        return;
      }

      if (formData.identificacion === "") {
        toast.warning("La cedula o ruc del traabajador no puede estar vacio");
        return;
      }

      if (formData.usuario === "") {
        toast.warning("Ingrese un nombre de usuario");
        return;
      }

      if (formData.contraseña === "") {
        toast.warning("Ingrese una contraseña para el usuario");
        return;
      }

      if (formData.estado === null) {
        toast.warning("Seleccione un estado para el usuario");
        return;
      }

      setLoading(true);
      console.log(formData);
      await props.onDone(formData);
      setLoading(false);
      handleClose();
    },
  });

  useEffect(() => {
    if (props.initialData) setInitialValues(props.initialData);
  }, [props.initialData]);

  return (
    <>
      <div
        className={`fixed inset-0 flex items-center justify-center z-50 ${
          props.visible ? "" : "hidden"
        }`}
      >
        <div className="fixed inset-0 bg-black opacity-50"></div>
        <div className="bg-white p-6 rounded shadow-lg z-10 w-2/3 h-5/6 overflow-y-auto">
          <form onSubmit={formik.handleSubmit}>
            <div
              style={{ color: theme.colors.blue }}
              className="text-center text-xl mb-2 font-semibold"
            >
              Usuario
            </div>
            <hr />
            <div className="grid md:grid-cols-2 grid-cols-1 gap-4 mb-3">
              <div>
                <label className="text-gray-700 text-sm font-bold mb-2">
                  Nombre del usuario
                </label>

                <input
                  className="appearance-none border-2 border-gray-200 rounded w-full py-2 px-4 text-gray-700 leading-tight focus:outline-none focus:bg-white focus:border-purple-500"
                  type="text"
                  placeholder="Nombre de Usuario"
                  name="nombre"
                  onChange={formik.handleChange}
                  value={formik.values.nombre}
                />
              </div>
              <div>
                <label className="text-gray-700 text-sm font-bold mb-2">
                  Cedula o RUC
                </label>

                <input
                  className="appearance-none border-2 border-gray-200 rounded w-full py-2 px-4 text-gray-700 leading-tight focus:outline-none focus:bg-white focus:border-purple-500"
                  type="text"
                  placeholder="Cedula o Ruc"
                  name="identificacion"
                  onChange={formik.handleChange}
                  value={formik.values.identificacion}
                />
              </div>

              <div>
                <label className="text-gray-700 text-sm font-bold mb-2">
                  Nombre de Usaurio
                </label>

                <input
                  className="appearance-none border-2 border-gray-200 rounded w-full py-2 px-4 text-gray-700 leading-tight focus:outline-none focus:bg-white focus:border-purple-500"
                  type="text"
                  placeholder="Nombre de Usuario"
                  name="usuario"
                  onChange={formik.handleChange}
                  value={formik.values.usuario}
                />
              </div>
              <div>
                <label className="text-gray-700 text-sm font-bold mb-2">
                  Contraseña
                </label>

                <input
                  className="appearance-none border-2 border-gray-200 rounded w-full py-2 px-4 text-gray-700 leading-tight focus:outline-none focus:bg-white focus:border-purple-500"
                  type="password"
                  placeholder="Password"
                  name="contraseña"
                  onChange={formik.handleChange}
                  value={formik.values.contraseña}
                />
              </div>
              <div>
                <label className="text-gray-700 text-sm font-bold mb-2">
                  E-mail
                </label>

                <input
                  className="appearance-none border-2 border-gray-200 rounded w-full py-2 px-4 text-gray-700 leading-tight focus:outline-none focus:bg-white focus:border-purple-500"
                  type="email"
                  placeholder="Correo electrónico"
                  name="correo"
                  onChange={formik.handleChange}
                  value={formik.values.correo}
                />
              </div>
              <div>
                <label className="text-gray-700 text-sm font-bold mb-2">
                  Tipo de Rol
                </label>

                <select
                  className="border border-gray-300 text-gray-900 text-sm rounded focus:ring-blue-500 focus:border-blue-500 block w-full py-2 px-4 dark:bg-gray-700 dark:border-gray-600 dark:placeholder-gray-400 dark:text-white dark:focus:ring-blue-500 dark:focus:border-blue-500"
                  aria-label="Default select rol"
                  name="rol"
                  onChange={(e) => {
                    const value = parseInt(e.target.value, 10);
                    formik.setFieldValue("rol", value); // Actualiza el valor del rol
                    if (value !== 3) {
                      formik.setFieldValue("medico", null); // Limpia el médico si no es rol médico
                    }
                  }}
                  value={formik.values.rol}
                  defaultValue={1}
                >
                  <option value={0}>Administrador</option>
                  <option value={1}>Bodeguero</option>
                  <option value={2}>Cliente</option>
                </select>
              </div>

              <div>
                <label className="text-gray-700 text-sm font-bold mb-2">
                  Estado
                </label>

                <select
                  className="border border-gray-300 text-gray-900 text-sm rounded focus:ring-blue-500 focus:border-blue-500 block w-full py-2 px-4 dark:bg-gray-700 dark:border-gray-600 dark:placeholder-gray-400 dark:text-white dark:focus:ring-blue-500 dark:focus:border-blue-500"
                  aria-label="Default select role"
                  name="estado"
                  onChange={formik.handleChange}
                  value={formik.values.estado}
                >
                  <option value="" selected disabled>
                    Seleccione una opcion
                  </option>
                  <option value="Activo">Activo</option>
                  <option value="Inactivo">Inactivo</option>
                </select>
              </div>
            </div>
            <hr />
            <button
              className="bg-transparent hover:bg-blue-500 text-blue-700 font-semibold hover:text-white py-2 px-4 border border-blue-500 hover:border-transparent rounded mb-4"
              type="submit"
            >
              Guardar
            </button>
          </form>
          <button
            className="bg-transparent hover:bg-gray-500 text-gray-700 font-semibold hover:text-white py-2 px-4 border border-gray-500 hover:border-transparent rounded"
            onClick={handleClose}
          >
            Cancelar
          </button>
        </div>
      </div>
    </>
  );
};
export default UserModal;



================================================
FILE: pages/components/tab_container/index.tsx
================================================
import { useState } from "react";

export type TabPanel = {
  name: string;
  content: React.ReactNode;
};

type Props = {
  tabPanels: Array<TabPanel>;
  style?: React.CSSProperties;
};

function TabContainer({ tabPanels, style }: Props) {
  const [activeTab, setActiveTab] = useState(0);

  return (
    <div className="tab-panel">
      <div className="tab-buttons">
        {tabPanels.map((tab, index) => (
          <button
            key={index}
            className={`tab-button ${activeTab === index ? "active" : ""}`}
            onClick={() => setActiveTab(index)}
          >
            {tab.name}
          </button>
        ))}
      </div>
      <div className="p-4">
        {tabPanels.map((tab, index) => (
          <div key={index} className={`${activeTab === index ? "active" : "hidden"}`}>
            {tab.content}
          </div>
        ))}
      </div>
    </div>
  );
}

export default TabContainer;



================================================
FILE: pages/components/tab_container/styles.tsx
================================================
import styled from "styled-components";
import theme from "../../../controllers/styles/theme";

 const NavStyler = styled.div`
  .nav-link{
    color: ${theme.colors.grey};
    cursor: pointer;
  }
  .active{
    color: blue !important;
  }
`

export default NavStyler


================================================
FILE: pages/components/tree_table/index.tsx
================================================
import TreeList, {
  Column,
  HeaderFilter,
  SearchPanel,
  Button,
  Editing,
  Scrolling,
  Paging,
  Pager,
  Selection,
} from "devextreme-react/tree-list";
import { useEffect, useState } from "react";
import { loadMessages } from "devextreme/localization";
import TableContainer, { TableContainerProps } from "./styles";

export type ColumnData = {
  dataField: string;
  caption: string;
  dataType?: any;
  headerCellRender?: (data: any) => React.ReactNode;
  cellRender?: (params: any) => React.ReactNode;
  subColumns?: ColumnData[];
  width?: number;
  minWidth?: number;
  alignment?: "left" | "center" | "right";
  cssClass?: string;
};

export type TableButtons = {
  cssClass?: string;
  show?: (rowData: any) => void;
  edit?: (rowData: any) => void;
  edit2?: (rowData: any) => void;
  delete?: (rowData: any) => void;
  download?: (rowData: any) => void;
};

export type DefaultActions = {
  updating: boolean;
  deleting: boolean;
  adding: boolean;
};

type Props = {
  id?: string;
  keyExpr?: string;
  columns: ColumnData[];
  dataSource: any[];
  columnAutoWidth?: boolean;
  buttons?: TableButtons;
  searchPanel?: boolean;
  headerFilter?: boolean;
  columnHidingEnabled?: boolean;
  defaultActions?: DefaultActions;
  style?: React.CSSProperties;
  colors?: TableContainerProps;
  buttonsFirst?: boolean;
  rowAlternationEnabled?: string;
  onRow?: {
    removed: (data: any) => Promise<void> | void;
    updated: (data: any) => Promise<void> | void;
    inserted: (data: any) => Promise<void> | void;
  };
  scrolling?: boolean;
  paging?: boolean;
  pageSize?: number;
  showNavigationButtons?: boolean;
  infoText?: (actual: string, total: string, items: string) => string;
  showNavigationInfo?: boolean;
  showLines?: boolean;
  onSelectedRows?: (values: Array<any>) => void;
};

const columnsRender = (cols: ColumnData[], index = "1_"): React.ReactNode => {
  return cols.map((column, columnindex) => {
    if (column.subColumns !== undefined) {
      return (
        //@ts-ignore
        <Column
          cssClass={column.cssClass}
          key={index + columnindex}
          caption={column.caption}
          headerCellRender={column.headerCellRender}
          width={column.width}
          minWidth={column.minWidth}
          alignment={column.alignment}
        >
          {columnsRender(column.subColumns, index + columnindex + "_")}
        </Column>
      );
    } else {
      return (
        <Column
          cssClass={column.cssClass}
          key={index + columnindex}
          dataField={column.dataField}
          caption={column.caption}
          headerCellRender={column.headerCellRender}
          cellRender={column.cellRender}
          width={column.width}
          minWidth={column.minWidth}
          alignment="center"
        />
      );
    }
  });
};

const allButtons = (
  buttons?: TableButtons,
  defaultActions?: DefaultActions
) => {
  return buttons ? (
    //@ts-ignore
    <Column type="buttons" caption="Acciones" cssClass={buttons.cssClass}>
      {buttons.show && (
        <Button
          text="mostar"
          hint="mostar"
          icon="/show.svg"
          onClick={({ row }: any) => buttons.show!(row.data)}
          cssClass="actionButtonShow"
        />
      )}
      {buttons.edit && (
        <Button
          text="editar"
          hint="editar"
          icon="/edit.svg"
          onClick={({ row }: any) => buttons.edit!(row.data)}
          cssClass="actionButtonEdit"
        />
      )}
      {buttons.edit2 && (
        <Button
          text="Medico"
          hint="Medico"
          icon="/tratamiento.png"
          onClick={({ row }: any) => buttons.edit2!(row.data)}
          cssClass="actionButtonEdit2"
        />
      )}
      {buttons.delete && (
        <Button
          text="eliminar"
          hint="eliminar"
          icon="/delete.svg"
          onClick={({ row }: any) => buttons.delete!(row.data)}
          cssClass="actionButtonDelete"
        />
      )}
      {buttons.download && (
        <Button
          text="descargar"
          hint="descargar"
          icon="/download.svg"
          onClick={({ row }: any) => buttons.download!(row.data)}
          cssClass="actionButtonDownload"
        />
      )}
    </Column>
  ) : (
    defaultActions && (
      //@ts-ignore
      <Column type="buttons" caption="Acciones">
        <Button
          name="edit"
          hint="editar"
          text="editar"
          icon="/edit.svg"
          cssClass="actionButtonEdit"
        />
        <Button
          name="delete"
          hint="eliminar"
          text="eliminar"
          icon="/delete.svg"
          cssClass="actionButtonDelete"
        />
        <Button name="save" hint="guardar" text="guardar" icon="/save.svg" />
        <Button
          name="cancel"
          hint="cancelar"
          text="cancelar"
          icon="/cancel.svg"
        />
      </Column>
    )
  );
};

loadMessages({
  en: {
    Yes: "Si",
    No: "No",
    "dxList-selectAll": "Todos",
  },
});

const TreeTable = ({
  id = "treeTable",
  keyExpr = "id",
  columns,
  dataSource,
  columnAutoWidth = true,
  buttons,
  searchPanel = true,
  headerFilter = true,
  defaultActions,
  style,
  columnHidingEnabled = false,
  colors,
  buttonsFirst = false,
  onRow,
  scrolling = false,
  paging = false,
  pageSize = 20,
  showNavigationButtons = false,
  infoText,
  showNavigationInfo = false,
  showLines = true,
  onSelectedRows,
}: Props) => {
  const [tableData, setTableData] = useState<any[]>(dataSource);
  const [selectedRowKeys, setSelectedRowsKeys] = useState([]);

  const onSelectionChanged = (e: any) => {
    setSelectedRowsKeys(e.selectedRowKeys);
    onSelectedRows(e.selectedRowsData);
  };

  useEffect(() => setTableData(dataSource), [dataSource]);
  return (
    <TableContainer {...colors}>
      {/* @ts-ignore */}
      <TreeList
        id={id}
        dataSource={tableData}
        columnAutoWidth={columnAutoWidth}
        showBorders={showLines}
        showRowLines={showLines}
        noDataText="No hay datos ingresados..."
        dataStructure="plain"
        rootValue="-1"
        keyExpr={keyExpr}
        rowAlternationEnabled={true}
        style={style}
        onRowRemoved={(e) => onRow.removed(e.data)}
        onRowUpdated={(e) => onRow.updated(e.data)}
        onRowInserted={(e) => onRow.inserted(e.data)}
        selectedRowKeys={selectedRowKeys}
        onSelectionChanged={onSelectionChanged}
      >
        {onSelectedRows && <Selection mode="multiple" />}
        {(scrolling || paging) && <Scrolling mode="standard" />}
        <Paging enabled={paging} defaultPageSize={pageSize} />
        <Pager
          showNavigationButtons={showNavigationButtons}
          infoText={infoText && infoText("{0}", "{1}", "{2}")}
          showInfo={showNavigationInfo}
        />
        {searchPanel && <SearchPanel visible={true} width={250} />}
        {headerFilter && (
          <HeaderFilter
            visible={true}
            texts={{
              cancel: "Cancelar",
              ok: "Filtrar",
              emptyValue: "Sin asignar",
            }}
          />
        )}
        {buttonsFirst && allButtons(buttons, defaultActions)}
        {columnsRender(columns)}
        {!buttonsFirst && allButtons(buttons, defaultActions)}
        {defaultActions && (
          <Editing
            allowUpdating={defaultActions?.updating ?? false}
            allowDeleting={defaultActions?.deleting ?? false}
            allowAdding={defaultActions?.adding ?? false}
            texts={{
              confirmDeleteMessage:
                "¿Estas seguro que deseas eliminar este dato?",
            }}
            mode="row"
          />
        )}
      </TreeList>
    </TableContainer>
  );
};

export default TreeTable;



================================================
FILE: pages/components/tree_table/styles.tsx
================================================
import styled from "styled-components";
import theme from "../../../controllers/styles/theme";

export type TableContainerProps = {
  headerBackground?: string;
  contentBackground?: string;
  headerColor?: string;
  contentColor?: string;
};

 const TableContainer = styled.div<TableContainerProps>`
  .dx-treelist {
    font-size: 12px;
  }
  .dx-treelist .dx-row > td {
    padding: 4px 6px;
  }
  .dx-treelist-headers {
    ${({ headerBackground }: TableContainerProps) => {
      if (headerBackground) return `background-color: ${headerBackground};`;
    }}
    ${({ headerColor }: TableContainerProps) => {
      if (headerColor) return `color: ${headerColor};`;
    }}
  }
  .dx-header-filter {
    ${({ headerColor }: TableContainerProps) => {
      if (headerColor) return `color: ${headerColor};`;
    }}
  }
  .dx-treelist-rowsview {
    ${({ contentBackground }: TableContainerProps) => {
      if (contentBackground) return `background-color: ${contentBackground};`;
    }}
    ${({ contentColor }: TableContainerProps) => {
      if (contentColor) return `color: ${contentColor};`;
    }}
  }
  .dx-info {
    color: black;
    opacity: 1;
  }
  .dx-treelist-headers {
    border-color: ${theme.colors.blue};
  }
  .dx-treelist-headers td {
    border-color: ${theme.colors.blue};
  }
  .dx-treelist-rowsview {
    border-color: ${theme.colors.blue};
  }
  .dx-treelist-rowsview td {
    border-color: ${theme.colors.blue};
  }
`;
export default TableContainer


================================================
FILE: pages/layouts/role_layout.tsx
================================================
import { useAuth } from "../../controllers/hooks/use_auth";
import { UserRole } from "../../models";
import { CheckPermissions } from "../../controllers/utils/check_permissions";

type Props = {
  permissions: Array<UserRole>;
  children: React.ReactNode;
};

const RoleLayout = (props: Props) => {
  const { auth } = useAuth();
  if (CheckPermissions(auth, props.permissions)) return <>{props.children}</>;
  return <div>No tiene permiso para entrar a esta Página</div>;
};

export default RoleLayout;



================================================
FILE: pages/layouts/session_layout.tsx
================================================
import { useAuth } from "../../controllers/hooks/use_auth";
import { useEffect, useState } from "react";
import LoadingContainer from "../components/loading_container";
import { useRouter } from "next/router";
import LoginPage from "../login";

type Props = {
  rol?: Array<number>;
  children: React.ReactNode;
};

// controla el inicio de sesión en la app
const SessionLayout = (props: Props) => {
  const { auth } = useAuth();
  const router = useRouter();
  const [loggedIn, setLoggedIn] = useState<boolean | null>(null);

  const publicRoutes = ["/login", "/registro", "/recuperar"];
  const isPublicRoute = publicRoutes.includes(router.pathname);

  useEffect(() => {
    setLoggedIn(auth !== null);
  }, [auth]);

  return (
    <LoadingContainer visible={loggedIn === null && !isPublicRoute}>
      {loggedIn || isPublicRoute ? <>{props.children}</> : <LoginPage />}
    </LoadingContainer>
  );
};

export default SessionLayout;



================================================
FILE: pages/layouts/config/modelos/index.tsx
================================================
import React, { useEffect, useState } from "react";
import { toast } from "react-toastify";
import LoadingContainer from "../../../components/loading_container";
import { useAuth } from "../../../../controllers/hooks/use_auth";
import { ResponseData, ModelosHerramienta } from "../../../../models";
import HttpClient from "../../../../controllers/utils/http_client";
import TreeTable, { ColumnData } from "../../../components/tree_table";
import UbicacionesModal from "../../../components/modals/modalUbicaciones";
import ModelosModal from "../../../components/modals/modalUbicaciones";
import ModalModelos from "../../../components/modals/modalModelos";

const ModelosPanel = () => {
  const { auth } = useAuth();
  const [loading, setLoading] = useState<boolean>(true);
  const [modalVisible, setModalVisible] = useState<boolean>(false);
  const [tableData, setTableData] = useState<Array<ModelosHerramienta>>([]);
  const [editingUbicaciones, setEditingUbicaciones] =
    useState<ModelosHerramienta | null>(null);

  const loadData = async () => {
    setLoading(true);
    const response = await HttpClient(
      "/api/modelos",
      "GET",
      auth.usuario,
      auth.rol
    );
    if (response.success) {
      const users: Array<any> = response.data;
      setTableData(users);
    } else {
      toast.warning(response.message);
    }
    setLoading(false);
  };

  // ejecuta funcion al renderizar la vista
  useEffect(() => {
    loadData();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  const showModal = () => setModalVisible(true);
  const hideModal = async () => {
    if (editingUbicaciones != null) setEditingUbicaciones(null);
    setModalVisible(false);
    await loadData();
  };

  const columns: ColumnData[] = [
    {
      dataField: "nombre",
      caption: "Nombre",
    },
  ];

  const buttons = {
    edit: (rowData: any) => {
      setEditingUbicaciones(rowData);
      showModal();
    },
  };

  return (
    <div style={{ padding: "40px 0" }}>
      <button
        className="text-center bg-transparent hover:bg-blue-600 text-blue-500 font-semibold hover:text-white py-2 px-4 border border-blue-500 hover:border-transparent rounded"
        onClick={showModal}
      >
        Crear modelo
      </button>
      <LoadingContainer visible={loading} miniVersion>
        <TreeTable
          dataSource={tableData}
          columns={columns}
          buttons={buttons}
          searchPanel={true}
          colors={{ headerBackground: "#F8F9F9", headerColor: "#466cf2" }}
          paging
          showNavigationButtons
          showNavigationInfo
          pageSize={10}
          infoText={(actual, total, items) =>
            `Página ${actual} de ${total} (${items} Modelos)`
          }
        />
      </LoadingContainer>
      <ModalModelos
        visible={modalVisible}
        close={hideModal}
        initialData={editingUbicaciones}
        onDone={async (newUser: ModelosHerramienta) => {
          console.log(newUser);
          const response: ResponseData =
            editingUbicaciones == null
              ? await HttpClient(
                  "/api/modelos",
                  "POST",
                  auth.usuario,
                  auth.rol,
                  newUser
                )
              : await HttpClient(
                  "/api/modelos",
                  "PUT",
                  auth.usuario,
                  auth.rol,
                  newUser
                );
          if (response.success) {
            toast.success(
              editingUbicaciones == null
                ? "Modelo creado!"
                : "Modelo actualizado!"
            );
          } else {
            toast.warning(response.message);
          }
        }}
      />
    </div>
  );
};

export default ModelosPanel;



================================================
FILE: pages/layouts/config/ubicaciones/index.tsx
================================================
import React, { useEffect, useState } from "react";
import { toast } from "react-toastify";
import LoadingContainer from "../../../components/loading_container";
import { useAuth } from "../../../../controllers/hooks/use_auth";
import { ResponseData, Ubicaciones } from "../../../../models";
import HttpClient from "../../../../controllers/utils/http_client";
import TreeTable, { ColumnData } from "../../../components/tree_table";
import UbicacionesModal from "../../../components/modals/modalUbicaciones";

const UbicacionesPanel = () => {
  const { auth } = useAuth();
  const [loading, setLoading] = useState<boolean>(true);
  const [modalVisible, setModalVisible] = useState<boolean>(false);
  const [tableData, setTableData] = useState<Array<Ubicaciones>>([]);
  const [editingUbicaciones, setEditingUbicaciones] =
    useState<Ubicaciones | null>(null);

  const loadData = async () => {
    setLoading(true);
    const response = await HttpClient(
      "/api/ubicaciones",
      "GET",
      auth.usuario,
      auth.rol
    );
    if (response.success) {
      const users: Array<any> = response.data;
      setTableData(users);
    } else {
      toast.warning(response.message);
    }
    setLoading(false);
  };

  // ejecuta funcion al renderizar la vista
  useEffect(() => {
    loadData();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  const showModal = () => setModalVisible(true);
  const hideModal = async () => {
    if (editingUbicaciones != null) setEditingUbicaciones(null);
    setModalVisible(false);
    await loadData();
  };

  const columns: ColumnData[] = [
    {
      dataField: "nombre",
      caption: "Nombre",
    },
  ];

  const buttons = {
    edit: (rowData: any) => {
      setEditingUbicaciones(rowData);
      showModal();
    },
  };

  return (
    <div style={{ padding: "40px 0" }}>
      <button
        className="text-center bg-transparent hover:bg-blue-600 text-blue-500 font-semibold hover:text-white py-2 px-4 border border-blue-500 hover:border-transparent rounded"
        onClick={showModal}
      >
        Crear ubicacion
      </button>
      <LoadingContainer visible={loading} miniVersion>
        <TreeTable
          dataSource={tableData}
          columns={columns}
          buttons={buttons}
          searchPanel={true}
          colors={{ headerBackground: "#F8F9F9", headerColor: "#466cf2" }}
          paging
          showNavigationButtons
          showNavigationInfo
          pageSize={10}
          infoText={(actual, total, items) =>
            `Página ${actual} de ${total} (${items} Ubicaciones)`
          }
        />
      </LoadingContainer>
      <UbicacionesModal
        visible={modalVisible}
        close={hideModal}
        initialData={editingUbicaciones}
        onDone={async (newUser: Ubicaciones) => {
          console.log(newUser);
          const response: ResponseData =
            editingUbicaciones == null
              ? await HttpClient(
                  "/api/ubicaciones",
                  "POST",
                  auth.usuario,
                  auth.rol,
                  newUser
                )
              : await HttpClient(
                  "/api/ubicaciones",
                  "PUT",
                  auth.usuario,
                  auth.rol,
                  newUser
                );
          if (response.success) {
            toast.success(
              editingUbicaciones == null
                ? "Ubicacion creada!"
                : "Ubicacion actualizada!"
            );
          } else {
            toast.warning(response.message);
          }
        }}
      />
    </div>
  );
};

export default UbicacionesPanel;



================================================
FILE: pages/layouts/config/users/index.tsx
================================================
import React, { useEffect, useState } from "react";
import { toast } from "react-toastify";
import LoadingContainer from "../../../components/loading_container";
import { useAuth } from "../../../../controllers/hooks/use_auth";
import { ResponseData, Usuario } from "../../../../models";
import HttpClient from "../../../../controllers/utils/http_client";
import TreeTable, { ColumnData } from "../../../components/tree_table";
import UserModal from "../../../components/modals/user";

const UsersPanel = () => {
  const { auth } = useAuth();
  const [loading, setLoading] = useState<boolean>(true);
  const [modalVisible, setModalVisible] = useState<boolean>(false);
  const [tableData, setTableData] = useState<Array<Usuario>>([]);
  const [editingUser, setEditingUser] = useState<Usuario | null>(null);

  const loadData = async () => {
    setLoading(true);
    const response = await HttpClient(
      "/api/user",
      "GET",
      auth.usuario,
      auth.rol
    );
    if (response.success) {
      const users: Array<any> = response.data;
      setTableData(users);
    } else {
      toast.warning(response.message);
    }
    setLoading(false);
  };

  // ejecuta funcion al renderizar la vista
  useEffect(() => {
    loadData();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  const showModal = () => setModalVisible(true);
  const hideModal = async () => {
    if (editingUser != null) setEditingUser(null);
    setModalVisible(false);
    await loadData();
  };

  const columns: ColumnData[] = [
    {
      dataField: "nombre",
      caption: "Nombre",
    },
    {
      dataField: "usuario",
      caption: "Usuario",
    },
    {
      dataField: "correo",
      caption: "E-mail",
    },
    {
      dataField: "identificacion",
      caption: "Cedula o RUC",
    },
    {
      dataField: "rol",
      caption: "Rol",
      cellRender: ({ text }: any) => {
        switch (text) {
          case "0":
            return "AdministradorSistema";
          case "1":
            return "Bodeguero";
          case "2":
            return "Cliente";
          default:
            return "";
        }
      },
    },
  ];

  const buttons = {
    edit: (rowData: any) => {
      setEditingUser(rowData);
      showModal();
    },
    delete: async (rowData: any) => {
      await HttpClient(
        "/api/user/" + rowData.id,
        "DELETE",
        auth.usuario,
        auth.rol
      );
      toast.success("Usuario eliminado");
      await loadData();
    },
  };

  return (
    <div style={{ padding: "40px 0" }}>
      <button
        className="text-center bg-transparent hover:bg-blue-600 text-blue-500 font-semibold hover:text-white py-2 px-4 border border-blue-500 hover:border-transparent rounded"
        onClick={showModal}
      >
        Crear Usuario
      </button>
      <LoadingContainer visible={loading} miniVersion>
        <TreeTable
          dataSource={tableData}
          columns={columns}
          buttons={buttons}
          searchPanel={true}
          colors={{ headerBackground: "#F8F9F9", headerColor: "#466cf2" }}
          paging
          showNavigationButtons
          showNavigationInfo
          pageSize={10}
          infoText={(actual, total, items) =>
            `Página ${actual} de ${total} (${items} Usuarios)`
          }
        />
      </LoadingContainer>
      <UserModal
        visible={modalVisible}
        close={hideModal}
        initialData={editingUser}
        onDone={async (newUser: Usuario) => {
          console.log(newUser);
          const response: ResponseData =
            editingUser == null
              ? await HttpClient(
                  "/api/user",
                  "POST",
                  auth.usuario,
                  auth.rol,
                  newUser
                )
              : await HttpClient(
                  "/api/user",
                  "PUT",
                  auth.usuario,
                  auth.rol,
                  newUser
                );
          if (response.success) {
            toast.success(
              editingUser == null ? "Usuario creado!" : "Usuario actualizado!"
            );
          } else {
            toast.warning(response.message);
          }
        }}
      />
    </div>
  );
};

export default UsersPanel;



================================================
FILE: pages/layouts/login/index.tsx
================================================
/* eslint-disable @next/next/no-img-element */
import { useState } from "react";
import { useFormik } from "formik";
import { LoginData } from "../../../models";
import { toast } from "react-toastify";
import LoadingContainer from "../../components/loading_container";
import { useAuth } from "../../../controllers/hooks/use_auth";
import HttpClient from "../../../controllers/utils/http_client";

const currentYear = new Date().getFullYear();
// login de la app
const Login = () => {
  const [loading, setLoading] = useState<boolean>(false);
  // llama la funcion para iniciar sesion
  const { login } = useAuth();

  // valores del formulario
  const [initialValues, _setInitialValues] = useState<LoginData>({
    usuario: "",
    contraseña: "",
  });

  // envia los datos del formulario
  const onSubmit = async (formData: LoginData) => {
    setLoading(true);
    const response = await HttpClient("/api/login", "POST", "", -1, formData);
    if (response.success) {
      const data = response.data;
      login(data);
      console.log(formData);
    } else {
      toast.warning(response.message);
    }
    setLoading(false);
  };

  // maneja los datos y comportamiento del formulario
  const formik = useFormik({
    enableReinitialize: true,
    validateOnMount: true,
    validateOnBlur: true,
    validateOnChange: true,
    initialValues,
    onSubmit,
  });

  return (
    <>
      <title>Inicio de sesión</title>
      <section className="min-h-screen w-full flex items-center justify-center bg-gradient-to-r from-blue-400 via-blue-500 to-blue-600">
        <div className="flex flex-col items-center justify-center rounded-3xl shadow-lg bg-white w-full max-w-md p-8">
          <h2 className="text-center text-3xl font-extrabold text-blue-800 mb-6">
            Sistema de herramientas
          </h2>

          <LoadingContainer visible={loading} miniVersion>
            <form onSubmit={formik.handleSubmit} className="w-full">
              <div className="mb-6">
                <label
                  htmlFor="userName"
                  className="block text-sm font-medium text-gray-700"
                >
                  Nombre de Usuario
                </label>
                <input
                  type="text"
                  name="usuario"
                  value={formik.values.usuario}
                  onChange={formik.handleChange}
                  placeholder="Ingrese su usuario"
                  className="mt-1 block w-full h-12 px-4 py-2 border border-gray-300 rounded-lg shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
                />
              </div>
              <div className="mb-6">
                <label
                  htmlFor="password"
                  className="block text-sm font-medium text-gray-700"
                >
                  Contraseña
                </label>
                <input
                  type="password"
                  name="contraseña"
                  value={formik.values.contraseña}
                  onChange={formik.handleChange}
                  placeholder="Ingrese su contraseña"
                  className="mt-1 block w-full h-12 px-4 py-2 border border-gray-300 rounded-lg shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
                />
              </div>

              <button
                type="submit"
                className="w-full py-3 px-4 bg-blue-500 hover:bg-blue-600 text-white rounded-lg font-semibold transition-colors"
              >
                Iniciar Sesión
              </button>
            </form>
          </LoadingContainer>
        </div>
      </section>
    </>
  );
};

export default Login;



================================================
FILE: pages/layouts/register/index.tsx
================================================
/* eslint-disable @next/next/no-img-element */
import { useState } from "react";
import { useFormik } from "formik";
import { Usuario } from "../../../models";
import { toast } from "react-toastify";
import LoadingContainer from "../../components/loading_container";
import { useAuth } from "../../../controllers/hooks/use_auth";
import HttpClient from "../../../controllers/utils/http_client";

const currentYear = new Date().getFullYear();
// login de la app
const Register = () => {
  const [loading, setLoading] = useState<boolean>(false);
  // llama la funcion para iniciar sesion
  const { login } = useAuth();

  // valores del formulario
  const [initialValues, _setInitialValues] = useState<Usuario>({
    number: 0,
    identificacion: "",
    usuario: "",
    contraseña: "",
    nombre: "",
    correo: "",
    telefono: "",
    rol: 2,
    estado: "Activo",
  });

  // envia los datos del formulario
  const onSubmit = async (formData: Usuario) => {
    setLoading(true);
    const response = await HttpClient("/api/user", "POST", "", -1, formData);
    if (response.success) {
      const data = response.data;
      login(data);
      console.log(formData);
    } else {
      toast.warning(response.message);
    }
    setLoading(false);
  };

  // maneja los datos y comportamiento del formulario
  const formik = useFormik({
    enableReinitialize: true,
    validateOnMount: true,
    validateOnBlur: true,
    validateOnChange: true,
    initialValues,
    onSubmit,
  });

  return (
    <>
      <title>Registro de usuario</title>
      <section className="min-h-screen w-full flex items-center justify-center bg-gradient-to-r from-blue-400 via-blue-500 to-blue-600">
        <div className="flex flex-col items-center justify-center rounded-3xl shadow-lg bg-white w-full max-w-md p-8">
          <h2 className="text-center text-3xl font-extrabold text-blue-800 mb-6">
            Sistema de herramientas
          </h2>

          <LoadingContainer visible={loading} miniVersion>
            <form onSubmit={formik.handleSubmit} className="w-full">
              <div className="mb-6">
                <label
                  htmlFor="userName"
                  className="block text-sm font-medium text-gray-700"
                >
                  Nombre de Usuario
                </label>
                <input
                  type="text"
                  name="usuario"
                  value={formik.values.usuario}
                  onChange={formik.handleChange}
                  placeholder="Ingrese su usuario"
                  className="mt-1 block w-full h-12 px-4 py-2 border border-gray-300 rounded-lg shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
                />
              </div>
              <div className="mb-6">
                <label
                  htmlFor="password"
                  className="block text-sm font-medium text-gray-700"
                >
                  Contraseña
                </label>
                <input
                  type="password"
                  name="contraseña"
                  value={formik.values.contraseña}
                  onChange={formik.handleChange}
                  placeholder="Ingrese su contraseña"
                  className="mt-1 block w-full h-12 px-4 py-2 border border-gray-300 rounded-lg shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
                />
              </div>

              <button
                type="submit"
                className="w-full py-3 px-4 bg-blue-500 hover:bg-blue-600 text-white rounded-lg font-semibold transition-colors"
              >
                Iniciar Sesión
              </button>
            </form>
          </LoadingContainer>
        </div>
      </section>
    </>
  );
};

export default Register;



================================================
FILE: pages/solicitudes/index.tsx
================================================
/* eslint-disable react/no-unescaped-entities */
import { Button } from "react-bootstrap";
import Sidebar from "../components/sidebar";
import { CheckPermissions } from "../../controllers/utils/check_permissions";
import Router from "next/router";
import { toast } from "react-toastify";
import { useAuth } from "../../controllers/hooks/use_auth";
import { useEffect, useState } from "react";
import HttpClient from "../../controllers/utils/http_client";
import { Solicitude } from "../../models";
import TreeTable, { ColumnData } from "../components/tree_table";

type Props = {
  dates: Array<string>;
  sm?: number;
  md?: number;
  lg?: number;
  xl?: number;
  inTabs?: boolean;
};

export const SolicitudePage = (props: Props) => {
  const { auth } = useAuth();
  const [tableData, setTableData] = useState<Array<Solicitude>>([]);
  const [loading, setLoading] = useState<boolean>(true);

  const loadData = async () => {
    setLoading(true);

    var response = await HttpClient(
      "/api/solicitudes",
      "GET",
      auth.usuario,
      auth.rol
    );

    const solicitudes: Array<Solicitude> = response.data ?? [];
    const bodegasDelUsuario = solicitudes.filter(
      (bodega) =>
        bodega.solicitante?.toLowerCase() === auth.usuario.toLowerCase() ||
        bodega.receptor?.toLowerCase() === auth.nombre.toLowerCase()
    );
    console.log(bodegasDelUsuario);
    setTableData(bodegasDelUsuario);
    setLoading(false);
  };

  useEffect(() => {
    loadData();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  const columns: ColumnData[] = [
    {
      dataField: "number",
      caption: "#",
      alignment: "center",
      cssClass: "bold",
    },
    {
      dataField: "solicitante",
      caption: "Solicitante",
      alignment: "center",
      cssClass: "bold",
    },
    {
      dataField: "receptor",
      caption: "Receptor",
      alignment: "center",
      cssClass: "bold",
    },
    {
      dataField: "fecha",
      caption: "Fecha",
      alignment: "center",
      cssClass: "bold",
    },
    {
      dataField: "estado",
      caption: "Estado",
      alignment: "center",
      cssClass: "bold",
    },
  ];

  const buttons = {
    download: (rowData: Solicitude) =>
      CheckPermissions(auth, [0, 1, 2])
        ? Router.push({
            pathname: "/solicitudes/reporte/" + (rowData.id as string),
          })
        : toast.error("No puedes acceder"),
    edit: (rowData: Solicitude) => {
      // Verificar si las herramientas ya fueron entregadas
      if (rowData.estado?.toLowerCase() === "herramientas entregadas") {
        toast.error(
          "No puedes editar una solicitud con herramientas entregadas"
        );
        return;
      }

      // Verificar permisos del usuario
      if (!CheckPermissions(auth, [0, 1, 2])) {
        toast.error("No tienes permisos para editar esta solicitud");
        return;
      }

      // Redireccionar a la edición si pasa ambas validaciones
      Router.push({
        pathname: "/solicitudes/edit/" + (rowData.id as string),
      });
    },
  };
  return (
    <>
      <div className="flex h-screen">
        <div className="md:w-1/6 max-w-none">
          <Sidebar />
        </div>
        <div className="w-12/12 md:w-5/6 bg-blue-100">
          <div className="bg-white w-5/6 h-5/6 mx-auto">
            <div className="mt-6">
              <p className="md:text-4xl text-xl text-center pt-5 font-extrabold text-blue-500">
                Registro de herramientas prestadas
              </p>
            </div>
            {CheckPermissions(auth, [0, 1]) && (
              <Button
                className="text-white bg-blue-400 hover:bg-blue-500 focus:outline-none focus:ring-4 focus:ring-blue-300 font-medium rounded-full text-sm px-5 py-3 text-center mx-2 mb-2 mt-3 dark:focus:ring-blue-900"
                onClick={() =>
                  CheckPermissions(auth, [0, 1])
                    ? Router.push({ pathname: "/solicitudes/create" })
                    : toast.info("No puede ingresar solicitudes")
                }
              >
                Crear registro
              </Button>
            )}
            {CheckPermissions(auth, [2]) && (
              <Button
                className="text-white bg-blue-400 hover:bg-blue-500 focus:outline-none focus:ring-4 focus:ring-blue-300 font-medium rounded-full text-sm px-5 py-3 text-center mx-2 mb-2 mt-3 dark:focus:ring-blue-900"
                onClick={() =>
                  CheckPermissions(auth, [2])
                    ? Router.push({ pathname: "/solicitudes/createForClient" })
                    : toast.info("No puede ingresar solicitudes")
                }
              >
                Crear registro
              </Button>
            )}
            <div className="p-2">
              <TreeTable
                keyExpr="id"
                dataSource={tableData}
                columns={columns}
                searchPanel={true}
                buttons={buttons}
                colors={{ headerBackground: "#F8F9F9", headerColor: "#466cf2" }}
                buttonsFirst
                paging
                showNavigationButtons
                showNavigationInfo
                pageSize={10}
                infoText={(actual, total, items) =>
                  `Página ${actual} de ${total} (${items} solicitudes)`
                }
              />
            </div>
          </div>
        </div>
      </div>
    </>
  );
};

export default SolicitudePage;



================================================
FILE: pages/solicitudes/create/index.tsx
================================================
/* eslint-disable react/no-unescaped-entities */
import { Button } from "react-bootstrap";
import Sidebar from "../../components/sidebar";
import { useAuth } from "../../../controllers/hooks/use_auth";
import { useFormik } from "formik";
import Router from "next/router";
import { toast } from "react-toastify";
import {
  Herramienta,
  Solicitude,
  ResponseData,
  Usuario,
} from "../../../models";
import HttpClient from "../../../controllers/utils/http_client";
import { useEffect, useState } from "react";
import FormatedDate from "../../../controllers/utils/formated_date";
import Select from "react-select";

export const RegistroCreate = () => {
  const { auth } = useAuth();
  const [loading, setLoading] = useState(false);
  const [herramientas, setHerramientas] = useState<Herramienta[]>([]);
  const [client, setClient] = useState<Usuario[]>([]);
  const [selectedTool, setSelectedTool] = useState(null);

  // Cargar herramientas disponibles
  const loadProducts = async () => {
    setLoading(true);

    const response = await HttpClient(
      "/api/bodegas",
      "GET",
      auth.usuario,
      auth.rol
    );

    const bodegas = response.data ?? [];
    console.log("bodegas disponibles:", bodegas);
    const bodegasDelUsuario = bodegas.filter(
      (bodega) =>
        bodega.bodegueroAsignado.toLowerCase() === auth.usuario.toLowerCase()
    );

    // Extraemos todas las herramientas de todas las bodegas
    const herramientasDisponibles = bodegasDelUsuario
      .flatMap((bodega) => bodega.herramientas ?? []) // Aseguramos que herramientas exista
      .filter((herramienta) => herramienta.estado === "Disponible");

    console.log("Herramientas disponibles:", herramientasDisponibles);
    setHerramientas(herramientasDisponibles);

    setLoading(false);
  };

  // Cargar herramientas disponibles
  const loadClient = async () => {
    setLoading(true);

    const response = await HttpClient(
      "/api/user",
      "GET",
      auth.usuario,
      auth.rol
    );

    console.log(response.data);
    const clientesDisponibles = (response.data ?? []).filter(
      (clientes: any) => clientes.rol === 2
    );

    console.log("clientes clientesDisponibles:", clientesDisponibles);
    setClient(clientesDisponibles);

    setLoading(false);
  };

  useEffect(() => {
    loadProducts();
    loadClient();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  // Valores iniciales para la solicitud
  const initialValues: Solicitude = {
    number: 0, // Generar un número si es necesario
    herramientas: [],
    fecha: FormatedDate(), // Fecha formateada
    solicitante: auth?.nombre || "",
    receptor: "",
    estado: "No entregado"
  };

  // Configuración de Formik
  const formik = useFormik({
    initialValues,
    onSubmit: async (values) => {
      // Validaciones manuales antes de enviar
      if (!values.receptor.trim()) {
        toast.warning("El campo 'Receptor' es obligatorio.");
        return;
      }
  
      if (values.herramientas.length === 0) {
        toast.warning("Debes agregar al menos una herramienta.");
        return;
      }
  
      // Si pasa las validaciones, se envía el formulario
      setLoading(true);
      console.log("Valores del formulario:", values);
  
      const response = await HttpClient(
        "/api/solicitudes",
        "POST",
        auth.usuario,
        auth.rol,
        values
      );
  
      if (response.success) {
        console.log(values.herramientas);
        
        try {
          // 1. Obtener todas las bodegas para identificar dónde está cada herramienta
          const bodegasResponse = await HttpClient(
            "/api/bodegas",
            "GET",
            auth.usuario,
            auth.rol
          );
          
          const bodegas = bodegasResponse.data ?? [];
          
          // 2. Crear un mapa de herramientas a actualizar por bodega
          const actualizacionesPorBodega = {};
          
          // Agrupar herramientas por bodega
          for (const herramientaSolicitud of values.herramientas) {
            // Buscar la bodega que contiene esta herramienta
            for (const bodega of bodegas) {
              if (!bodega.herramientas) continue;
              
              const indiceHerramienta = bodega.herramientas.findIndex(
                h => h.id === herramientaSolicitud.id
              );
              
              if (indiceHerramienta !== -1) {
                // Esta herramienta está en esta bodega
                if (!actualizacionesPorBodega[bodega.id]) {
                  // Inicializar la entrada para esta bodega si no existe
                  actualizacionesPorBodega[bodega.id] = {
                    bodega: bodega,
                    herramientasActualizar: []
                  };
                }
                
                // Agregar esta herramienta a la lista de actualizaciones
                actualizacionesPorBodega[bodega.id].herramientasActualizar.push({
                  indice: indiceHerramienta,
                  id: herramientaSolicitud.id
                });
                
                // No es necesario seguir buscando en otras bodegas
                break;
              }
            }
          }
          
          // 3. Realizar las actualizaciones por bodega
          await Promise.all(
            Object.values(actualizacionesPorBodega).map(async (actualizacion) => {
              //@ts-ignore
              const { bodega, herramientasActualizar } = actualizacion;
              
              // Crear una copia de las herramientas de la bodega
              const herramientasActualizadas = [...bodega.herramientas];
              
              // Actualizar cada herramienta
              for (const { indice, id } of herramientasActualizar) {
                herramientasActualizadas[indice] = {
                  ...herramientasActualizadas[indice],
                  estado: "En uso"
                };
              }
              
              // Crear la bodega actualizada
              const bodegaActualizada = {
                ...bodega,
                herramientas: herramientasActualizadas
              };
              
              // Enviar la actualización al servidor
              return HttpClient(
                `/api/bodegas/`,
                "PUT",
                auth.usuario,
                auth.rol,
                bodegaActualizada
              );
            })
          );
          
          toast.success("Registro creado correctamente y herramientas actualizadas a 'En uso'!");
        } catch (error) {
          console.error("Error al actualizar las herramientas:", error);
          toast.warning("Registro creado pero hubo un problema al actualizar las herramientas.");
        }
        
        Router.back();
      } else {
        toast.warning(response.message);
      }
  
      setLoading(false);
    },
  });

  // Filtrar herramientas ya seleccionadas
  const herramientasDisponibles = herramientas.filter(
    (h) => !formik.values.herramientas.some((selected) => selected.id === h.id)
  );

  // Opciones para el Select con búsqueda
  const toolOptions = herramientasDisponibles.map((tool) => ({
    value: tool.id,
    label: `${tool.nombre} - ${tool.codigo} - ${tool.modelo} - ${tool.marca} - ${tool.ubicacion} - ${tool.serie}`,
  }));

  // Agregar herramienta
  const addHerramienta = () => {
    if (!selectedTool) return;
    const selectedToolData = herramientas.find(
      (tool) => tool.id === selectedTool.value
    );
    if (selectedToolData) {
      formik.setFieldValue("herramientas", [
        ...formik.values.herramientas,
        selectedToolData,
      ]);
      setSelectedTool(null);
    }
  };

  return (
    <div className="flex h-screen">
      <div className="md:w-1/6 max-w-none">
        <Sidebar />
      </div>
      <div className="w-12/12 md:w-5/6 bg-blue-100 p-4">
        <div className="bg-white w-5/6 mx-auto p-6 m-5 rounded-lg shadow-md">
          <h1 className="text-3xl font-bold text-blue-500 text-center mb-4">
            Crear registro de herramientas prestadas
          </h1>
          <form onSubmit={formik.handleSubmit}>
            {/* Datos del cliente */}
            <div className="mb-4">
              <label className="block text-blue-500 font-bold mb-2">
                Solicitante
              </label>
              <input
                type="text"
                name="solicitante"
                onChange={formik.handleChange}
                value={formik.values.solicitante}
                className="border p-2 w-full rounded-lg"
                placeholder="Nombre del solicitante"
                disabled
              />
            </div>
            <div className="mb-4">
              <label className="block text-blue-500 font-bold mb-2">
                Receptor
              </label>
              <select
                name="receptor"
                value={formik.values.receptor}
                onChange={formik.handleChange}
                className="shadow-sm bg-gray-50 border border-gray-300 text-gray-900 text-sm rounded-lg focus:ring-blue-500 focus:border-blue-500 block w-full p-2.5 dark:bg-gray-700 dark:border-gray-600 dark:placeholder-gray-400 dark:text-white dark:focus:ring-blue-500 dark:focus:border-blue-500 dark:shadow-sm-light"
              >
                <option value="">Seleccione un cliente</option>
                {client.map((ubic) => (
                  <option key={ubic.id} value={ubic.nombre}>
                    {ubic.nombre}
                  </option>
                ))}
              </select>
            </div>
            <div className="mb-4">
              <label className="block text-blue-500 font-bold mb-2">
                Fecha
              </label>
              <input
                type="text"
                name="fecha"
                value={formik.values.fecha}
                disabled
                className="border p-2 w-full bg-gray-200 rounded-lg"
              />
            </div>

            {/* Agregar herramientas */}
            <div className="mb-4">
              <p className="text-xl font-bold text-blue-500 mb-2">
                Agregar Herramientas
              </p>
              <div className="flex items-center gap-2">
                <div className="w-full">
                  <Select
                    value={selectedTool}
                    onChange={setSelectedTool}
                    options={toolOptions}
                    isSearchable
                    placeholder="Buscar herramienta..."
                    className="w-full"
                  />
                </div>
                <Button
                  className="bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded-lg"
                  type="button"
                  onClick={addHerramienta}
                >
                  Agregar
                </Button>
              </div>
            </div>

            {/* Listado de herramientas agregadas */}
            <div className="mb-4">
              <p className="text-xl font-bold text-blue-500 mb-2">
                Herramientas agregadas
              </p>
              {formik.values.herramientas.length === 0 ? (
                <p className="text-gray-500">No hay herramientas agregadas.</p>
              ) : (
                <ul className="border rounded-lg p-3 bg-gray-50">
                  {formik.values.herramientas.map((tool, index) => (
                    <li
                      key={index}
                      className="flex justify-between items-center border-b last:border-b-0 p-2"
                    >
                      <span>
                        {tool.nombre} - {tool.codigo} - ${tool.modelo} - ${tool.marca} - ${tool.ubicacion} - ${tool.serie}
                      </span>
                      <Button
                        className="bg-red-500 hover:bg-red-600 text-white font-bold py-1 px-3 rounded-lg"
                        size="sm"
                        onClick={() => {
                          const updatedTools =
                            formik.values.herramientas.filter(
                              (_, i) => i !== index
                            );
                          formik.setFieldValue("herramientas", updatedTools);
                        }}
                      >
                        Eliminar
                      </Button>
                    </li>
                  ))}
                </ul>
              )}
            </div>

            <Button
              type="submit"
              disabled={loading}
              className="bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-4 rounded-lg w-full"
            >
              {loading ? "Enviando..." : "Enviar Registro"}
            </Button>
          </form>
        </div>
      </div>
    </div>
  );
};

export default RegistroCreate;



================================================
FILE: pages/solicitudes/createForClient/index.tsx
================================================
/* eslint-disable react/no-unescaped-entities */
import { Button } from "react-bootstrap";
import Sidebar from "../../components/sidebar";
import { useAuth } from "../../../controllers/hooks/use_auth";
import { useFormik } from "formik";
import Router from "next/router";
import { toast } from "react-toastify";
import {
  Herramienta,
  Solicitude,
  ResponseData,
  Usuario,
  Bodega,
} from "../../../models";
import HttpClient from "../../../controllers/utils/http_client";
import { useEffect, useState } from "react";
import FormatedDate from "../../../controllers/utils/formated_date";
import Select from "react-select";

export const RegistroCreateForClient = () => {
  const { auth } = useAuth();
  const [loading, setLoading] = useState(false);
  const [herramientas, setHerramientas] = useState<Herramienta[]>([]);
  const [client, setClient] = useState<Usuario[]>([]);
  const [selectedTool, setSelectedTool] = useState(null);
  const [allBodegas, setAllBodegas] = useState<Bodega[]>([]);

  // Cargar herramientas disponibles
  const loadProducts = async () => {
    setLoading(true);
    const response = await HttpClient(
      "/api/bodegas",
      "GET",
      auth.usuario,
      auth.rol
    );
    const bodegas = response.data ?? [];

    setAllBodegas(bodegas); // guarda todas las bodegas para filtrarlas luego
    setLoading(false);
  };

  // Cargar herramientas disponibles
  const loadClient = async () => {
    setLoading(true);

    const response = await HttpClient(
      "/api/user",
      "GET",
      auth.usuario,
      auth.rol
    );

    const clientesDisponibles = (response.data ?? []).filter(
      (clientes: any) => clientes.rol === 1
    );

    console.log("clientes clientesDisponibles:", clientesDisponibles);
    setClient(clientesDisponibles);

    setLoading(false);
  };

  useEffect(() => {
    loadProducts();
    loadClient();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  // Valores iniciales para la solicitud
  const initialValues: Solicitude = {
    number: 0, // Generar un número si es necesario
    herramientas: [],
    fecha: FormatedDate(), // Fecha formateada
    solicitante: "",
    receptor: auth?.nombre,
    estado: "No entregado",
  };

  // Configuración de Formik
  const formik = useFormik({
    initialValues,
    onSubmit: async (values) => {
      // Validaciones manuales antes de enviar
      if (!values.receptor.trim()) {
        toast.warning("El campo 'Receptor' es obligatorio.");
        return;
      }

      if (values.herramientas.length === 0) {
        toast.warning("Debes agregar al menos una herramienta.");
        return;
      }

      // Si pasa las validaciones, se envía el formulario
      setLoading(true);
      console.log("Valores del formulario:", values);

      const response = await HttpClient(
        "/api/solicitudes",
        "POST",
        auth.usuario,
        auth.rol,
        values
      );

      if (response.success) {
        console.log(values.herramientas);

        try {
          // 1. Obtener todas las bodegas para identificar dónde está cada herramienta
          const bodegasResponse = await HttpClient(
            "/api/bodegas",
            "GET",
            auth.usuario,
            auth.rol
          );

          const bodegas = bodegasResponse.data ?? [];

          // 2. Crear un mapa de herramientas a actualizar por bodega
          const actualizacionesPorBodega = {};

          // Agrupar herramientas por bodega
          for (const herramientaSolicitud of values.herramientas) {
            // Buscar la bodega que contiene esta herramienta
            for (const bodega of bodegas) {
              if (!bodega.herramientas) continue;

              const indiceHerramienta = bodega.herramientas.findIndex(
                (h) => h.id === herramientaSolicitud.id
              );

              if (indiceHerramienta !== -1) {
                // Esta herramienta está en esta bodega
                if (!actualizacionesPorBodega[bodega.id]) {
                  // Inicializar la entrada para esta bodega si no existe
                  actualizacionesPorBodega[bodega.id] = {
                    bodega: bodega,
                    herramientasActualizar: [],
                  };
                }

                // Agregar esta herramienta a la lista de actualizaciones
                actualizacionesPorBodega[bodega.id].herramientasActualizar.push(
                  {
                    indice: indiceHerramienta,
                    id: herramientaSolicitud.id,
                  }
                );

                // No es necesario seguir buscando en otras bodegas
                break;
              }
            }
          }

          // 3. Realizar las actualizaciones por bodega
          await Promise.all(
            Object.values(actualizacionesPorBodega).map(
              async (actualizacion) => {
                //@ts-ignore
                const { bodega, herramientasActualizar } = actualizacion;

                // Crear una copia de las herramientas de la bodega
                const herramientasActualizadas = [...bodega.herramientas];

                // Actualizar cada herramienta
                for (const { indice, id } of herramientasActualizar) {
                  herramientasActualizadas[indice] = {
                    ...herramientasActualizadas[indice],
                    estado: "En uso",
                  };
                }

                // Crear la bodega actualizada
                const bodegaActualizada = {
                  ...bodega,
                  herramientas: herramientasActualizadas,
                };

                // Enviar la actualización al servidor
                return HttpClient(
                  `/api/bodegas/`,
                  "PUT",
                  auth.usuario,
                  auth.rol,
                  bodegaActualizada
                );
              }
            )
          );

          toast.success(
            "Registro creado correctamente y herramientas actualizadas a 'En uso'!"
          );
        } catch (error) {
          console.error("Error al actualizar las herramientas:", error);
          toast.warning(
            "Registro creado pero hubo un problema al actualizar las herramientas."
          );
        }

        Router.back();
      } else {
        toast.warning(response.message);
      }

      setLoading(false);
    },
  });

  // Filtrar herramientas ya seleccionadas
  const herramientasDisponibles = herramientas.filter(
    (h) => !formik.values.herramientas.some((selected) => selected.id === h.id)
  );

  // Opciones para el Select con búsqueda
  const toolOptions = herramientasDisponibles.map((tool) => ({
    value: tool.id,
    label: `${tool.nombre} - ${tool.codigo} - ${tool.modelo} - ${tool.marca} - ${tool.ubicacion} - ${tool.serie}`,
  }));

  // Agregar herramienta
  const addHerramienta = () => {
    if (!selectedTool) return;
    const selectedToolData = herramientas.find(
      (tool) => tool.id === selectedTool.value
    );
    if (selectedToolData) {
      formik.setFieldValue("herramientas", [
        ...formik.values.herramientas,
        selectedToolData,
      ]);
      setSelectedTool(null);
    }
  };

    useEffect(() => {
    if (!formik.values.solicitante) {
      setHerramientas([]);
      return;
    }

    const bodegasDelBodeguero = allBodegas.filter(
      (bodega) =>
        bodega.bodegueroAsignado.toLowerCase() ===
        formik.values.solicitante.toLowerCase()
    );

    const herramientasDisponibles = bodegasDelBodeguero
      .flatMap((bodega) => bodega.herramientas ?? [])
      .filter((herramienta) => herramienta.estado === "Disponible");

    setHerramientas(herramientasDisponibles);
  }, [formik.values.solicitante, allBodegas]);

  return (
    <div className="flex h-screen">
      <div className="md:w-1/6 max-w-none">
        <Sidebar />
      </div>
      <div className="w-12/12 md:w-5/6 bg-blue-100 p-4">
        <div className="bg-white w-5/6 mx-auto p-6 m-5 rounded-lg shadow-md">
          <h1 className="text-3xl font-bold text-blue-500 text-center mb-4">
            Crear registro de herramientas prestadas
          </h1>
          <form onSubmit={formik.handleSubmit}>
            {/* Datos del cliente */}
            <div className="mb-4">
              <label className="block text-blue-500 font-bold mb-2">
                Solicitante
              </label>
              <select
                name="solicitante"
                value={formik.values.solicitante}
                onChange={formik.handleChange}
                className="shadow-sm bg-gray-50 border border-gray-300 text-gray-900 text-sm rounded-lg focus:ring-blue-500 focus:border-blue-500 block w-full p-2.5 dark:bg-gray-700 dark:border-gray-600 dark:placeholder-gray-400 dark:text-white dark:focus:ring-blue-500 dark:focus:border-blue-500 dark:shadow-sm-light"
              >
                <option value="">Seleccione un bodeguero</option>
                {client.map((ubic) => (
                  <option key={ubic.id} value={ubic.nombre}>
                    {ubic.nombre}
                  </option>
                ))}
              </select>
            </div>
            <div className="mb-4">
              <label className="block text-blue-500 font-bold mb-2">
                Receptor
              </label>
              <input
                type="text"
                name="receptor"
                onChange={formik.handleChange}
                value={formik.values.receptor}
                className="border p-2 w-full rounded-lg"
                placeholder="Nombre del receptor"
                disabled
              />
            </div>
            <div className="mb-4">
              <label className="block text-blue-500 font-bold mb-2">
                Fecha
              </label>
              <input
                type="text"
                name="fecha"
                value={formik.values.fecha}
                disabled
                className="border p-2 w-full bg-gray-200 rounded-lg"
              />
            </div>

            {/* Agregar herramientas */}
            <div className="mb-4">
              <p className="text-xl font-bold text-blue-500 mb-2">
                Agregar Herramientas
              </p>
              <div className="flex items-center gap-2">
                <div className="w-full">
                  <Select
                    value={selectedTool}
                    onChange={setSelectedTool}
                    options={toolOptions}
                    isSearchable
                    placeholder="Buscar herramienta..."
                    className="w-full"
                  />
                  {herramientasDisponibles.length === 0 &&
                    formik.values.solicitante && (
                      <p className="text-red-500 text-sm mt-2">
                        No hay herramientas disponibles para este bodeguero.
                      </p>
                    )}
                </div>
                <Button
                  className="bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded-lg"
                  type="button"
                  onClick={addHerramienta}
                >
                  Agregar
                </Button>
              </div>
            </div>

            {/* Listado de herramientas agregadas */}
            <div className="mb-4">
              <p className="text-xl font-bold text-blue-500 mb-2">
                Herramientas agregadas
              </p>
              {formik.values.herramientas.length === 0 ? (
                <p className="text-gray-500">No hay herramientas agregadas.</p>
              ) : (
                <ul className="border rounded-lg p-3 bg-gray-50">
                  {formik.values.herramientas.map((tool, index) => (
                    <li
                      key={index}
                      className="flex justify-between items-center border-b last:border-b-0 p-2"
                    >
                      <span>
                        {tool.nombre} - {tool.codigo} - ${tool.modelo} - $
                        {tool.marca} - ${tool.ubicacion} - ${tool.serie}
                      </span>
                      <Button
                        className="bg-red-500 hover:bg-red-600 text-white font-bold py-1 px-3 rounded-lg"
                        size="sm"
                        onClick={() => {
                          const updatedTools =
                            formik.values.herramientas.filter(
                              (_, i) => i !== index
                            );
                          formik.setFieldValue("herramientas", updatedTools);
                        }}
                      >
                        Eliminar
                      </Button>
                    </li>
                  ))}
                </ul>
              )}
            </div>

            <Button
              type="submit"
              disabled={loading}
              className="bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-4 rounded-lg w-full"
            >
              {loading ? "Enviando..." : "Enviar Registro"}
            </Button>
          </form>
        </div>
      </div>
    </div>
  );
};

export default RegistroCreateForClient;



================================================
FILE: pages/solicitudes/edit/[id].tsx
================================================
/* eslint-disable react/no-unescaped-entities */
import { Button } from "react-bootstrap";
import Sidebar from "../../components/sidebar";
import { useAuth } from "../../../controllers/hooks/use_auth";
import { useFormik } from "formik";
import Router from "next/router";
import { toast } from "react-toastify";
import { Solicitude, ResponseData } from "../../../models";
import HttpClient from "../../../controllers/utils/http_client";
import { useEffect, useState } from "react";
import FormatedDate from "../../../controllers/utils/formated_date";
import Select from "react-select";

export const EditarRegistro = () => {
  const { auth } = useAuth();
  const [loading, setLoading] = useState(false);
  const [solicitudes, setsolicitudes] = useState<Solicitude[]>([]);
  const [selectedTool, setSelectedTool] = useState(null);
  const [initialValues, setInitialValues] = useState<Solicitude | null>(null);

  const loadData = async () => {
    setLoading(true);
    const solicitudeId = Router.query.id as string;
    const response = await HttpClient(
      `/api/solicitudes/${solicitudeId}`,
      "GET",
      auth.usuario,
      auth.rol
    );

    console.log("response.data:", response.data);
    setsolicitudes(response.data);
    setInitialValues(response.data);

    setLoading(false);
  };

  useEffect(() => {
    loadData();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  // Valores iniciales para la solicitud

  // Configuración de Formik
  const formik = useFormik({
    enableReinitialize: true,
    initialValues: initialValues || {
      number: 0, // Generar un número si es necesario
      herramientas: [],
      fecha: "",
      solicitante: "",
      receptor: "",
      estado: "",
    },
    onSubmit: async (values) => {
      // Si pasa las validaciones, se envía el formulario
      setLoading(true);
      console.log("Valores del formulario:", values);
      values.estado = "Herramientas entregadas"
      const response: ResponseData = await HttpClient(
        `/api/solicitudes`,
        "PUT",
        auth.usuario,
        auth.rol,
        values
      );

      if (response.success) {
        try {
          // 1. Obtener todas las bodegas para identificar dónde está cada herramienta
          const bodegasResponse = await HttpClient(
            "/api/bodegas",
            "GET",
            auth.usuario,
            auth.rol
          );

          const bodegas = bodegasResponse.data ?? [];

          // 2. Crear un mapa de herramientas a actualizar por bodega
          const actualizacionesPorBodega = {};

          // Agrupar herramientas por bodega
          for (const herramientaSolicitud of values.herramientas) {
            // Buscar la bodega que contiene esta herramienta
            for (const bodega of bodegas) {
              if (!bodega.herramientas) continue;

              const indiceHerramienta = bodega.herramientas.findIndex(
                (h) => h.id === herramientaSolicitud.id
              );

              if (indiceHerramienta !== -1) {
                // Esta herramienta está en esta bodega
                if (!actualizacionesPorBodega[bodega.id]) {
                  // Inicializar la entrada para esta bodega si no existe
                  actualizacionesPorBodega[bodega.id] = {
                    bodega: bodega,
                    herramientasActualizar: [],
                  };
                }

                // Agregar esta herramienta a la lista de actualizaciones
                actualizacionesPorBodega[bodega.id].herramientasActualizar.push(
                  {
                    indice: indiceHerramienta,
                    id: herramientaSolicitud.id,
                  }
                );

                // No es necesario seguir buscando en otras bodegas
                break;
              }
            }
          }

          // 3. Realizar las actualizaciones por bodega
          await Promise.all(
            Object.values(actualizacionesPorBodega).map(
              async (actualizacion) => {
                //@ts-ignore
                const { bodega, herramientasActualizar } = actualizacion;

                // Crear una copia de las herramientas de la bodega
                const herramientasActualizadas = [...bodega.herramientas];

                // Actualizar cada herramienta
                for (const { indice, id } of herramientasActualizar) {
                  herramientasActualizadas[indice] = {
                    ...herramientasActualizadas[indice],
                    estado: "Disponible",
                  };
                }

                // Crear la bodega actualizada
                const bodegaActualizada = {
                  ...bodega,
                  herramientas: herramientasActualizadas,
                };

                // Enviar la actualización al servidor
                return HttpClient(
                  `/api/bodegas/`,
                  "PUT",
                  auth.usuario,
                  auth.rol,
                  bodegaActualizada
                );
              }
            )
          );

          toast.success(
            "Registro creado correctamente y herramientas actualizadas a 'Disponible'!"
          );
          Router.back();
        } catch (error) {
          console.error("Error al actualizar las herramientas:", error);
          toast.warning(
            "Registro creado pero hubo un problema al actualizar las herramientas."
          );
        }
      } else {
        toast.warning(response.message);
      }

      //const response: ResponseData = await HttpClient(
      //  "/api/solicitudes",
      //  "POST",
      //  auth.usuario,
      //  auth.rol,
      //  values
      //);
      //
      //if (response.success) {
      //  toast.success("Registro creado correctamente!");
      //
      //} else {
      //  toast.warning(response.message);
      //}

      setLoading(false);
    },
  });

  return (
    <div className="flex h-screen">
      <div className="md:w-1/6 max-w-none">
        <Sidebar />
      </div>
      <div className="w-12/12 md:w-5/6 bg-blue-100 p-4">
        <div className="bg-white w-5/6 mx-auto p-6 m-5 rounded-lg shadow-md">
          <h1 className="text-3xl font-bold text-blue-500 text-center mb-4">
            Editar registro de herramientas prestadas
          </h1>
          <form onSubmit={formik.handleSubmit}>
            {/* Datos del cliente */}
            <div className="mb-4">
              <label className="block text-blue-500 font-bold mb-2">
                Solicitante
              </label>
              <input
                type="text"
                name="solicitante"
                onChange={formik.handleChange}
                value={formik.values.solicitante}
                className="border p-2 w-full rounded-lg"
                placeholder="Nombre del solicitante"
                disabled
              />
            </div>
            <div className="mb-4">
              <label className="block text-blue-500 font-bold mb-2">
                Receptor
              </label>
              <input
                type="text"
                name="receptor"
                onChange={formik.handleChange}
                value={formik.values.receptor}
                className="border p-2 w-full rounded-lg"
                placeholder="Nombre del receptor"
                disabled
              />
            </div>
            <div className="mb-4">
              <label className="block text-blue-500 font-bold mb-2">
                Fecha
              </label>
              <input
                type="text"
                name="fecha"
                value={formik.values.fecha}
                disabled
                className="border p-2 w-full bg-gray-200 rounded-lg"
              />
            </div>

            {/* Listado de herramientas agregadas */}
            <div className="mb-4">
              <p className="text-xl font-bold text-blue-500 mb-2">
                Herramientas agregadas
              </p>
              {formik.values.herramientas.length === 0 ? (
                <p className="text-gray-500">No hay herramientas agregadas.</p>
              ) : (
                <ul className="border rounded-lg p-3 bg-gray-50">
                  {formik.values.herramientas.map((tool, index) => (
                    <li
                      key={index}
                      className="flex justify-between items-center border-b last:border-b-0 p-2"
                    >
                      <span>
                        {tool.nombre} - {tool.codigo} - {tool.modelo} -
                        {tool.marca} - {tool.ubicacion} - {tool.serie}
                      </span>
                      <Button
                        className="bg-red-500 hover:bg-red-600 text-white font-bold py-1 px-3 rounded-lg"
                        size="sm"
                        onClick={() => {
                          const updatedTools =
                            formik.values.herramientas.filter(
                              (_, i) => i !== index
                            );
                          formik.setFieldValue("herramientas", updatedTools);
                        }}
                      >
                        Eliminar
                      </Button>
                    </li>
                  ))}
                </ul>
              )}
            </div>

            <Button
              type="submit"
              disabled={loading}
              className="bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-4 rounded-lg w-full"
            >
              {loading ? "Registrando..." : "Registrar herramientas entregas"}
            </Button>
          </form>
        </div>
      </div>
    </div>
  );
};

export default EditarRegistro;



================================================
FILE: pages/solicitudes/reporte/[id].tsx
================================================
/* eslint-disable react/no-unescaped-entities */
import Router from "next/router";
import { useState, useEffect, useRef } from "react";
import { toast } from "react-toastify";
import { useAuth } from "../../../controllers/hooks/use_auth";
import HttpClient from "../../../controllers/utils/http_client";
import { ResponseData, Solicitude, Herramienta } from "../../../models";
import Sidebar from "../../components/sidebar";
import { useReactToPrint } from "react-to-print";

const ReporteRegistro = () => {
  const { auth } = useAuth();
  const [loading, setLoading] = useState<boolean>(false);
  const [registro, setRegistro] = useState<Solicitude | null>(null);
  const [herramientasDetalles, setHerramientasDetalles] = useState<Herramienta[]>([]);
  const printRef = useRef(null);

  const loadData = async () => {
    if (Router.asPath !== Router.route) {
      setLoading(true);
      const registroId = Router.query.id as string;

      // Obtener los datos de la solicitud
      const response: ResponseData = await HttpClient(
        `/api/solicitudes/${registroId}`,
        "GET",
        auth.usuario,
        auth.rol
      );

      if (response.success) {
        const solicitud = response.data;
        setRegistro(solicitud);

        // Consultar los detalles de cada herramienta
        const herramientasPromises = solicitud.herramientas.map(async (herramienta) => {
          const herramientaResponse: ResponseData = await HttpClient(
            `/api/herramientas/${herramienta.id}`,
            "GET",
            auth.usuario,
            auth.rol
          );
          return herramientaResponse.success ? herramientaResponse.data : null;
        });

        const herramientasDetalles = await Promise.all(herramientasPromises);
        setHerramientasDetalles(herramientasDetalles.filter((h) => h !== null));
      } else {
        toast.error("Registro no encontrado.");
      }
      setLoading(false);
    } else {
      setTimeout(loadData, 1000);
    }
  };

  useEffect(() => {
    loadData();
  // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  const handlePrint = useReactToPrint({
    content: () => printRef.current,
    documentTitle: `Reporte_${registro?.id}`,
  });

  return (
    <>
      <div className="flex h-screen">
        <div className="md:w-1/6 max-w-none">
          <Sidebar />
        </div>
        <div className="w-12/12 md:w-5/6 bg-gray-100 p-4">
          <div className="bg-white w-11/12 mx-auto p-6 rounded-lg shadow-md">
            <h1 className="text-2xl font-bold text-center text-blue-500">
              Recibo de Entrega de Herramientas
            </h1>

            <div ref={printRef} className="p-4 border mt-4">
              {/* Encabezado */}
              <div className="text-center">
                <p className="font-bold text-lg">
                  BRIGADA DE AVIACIÓN DEL EJÉRCITO BAE 15 "PAQUISHA"
                </p>
                <p className="text-sm">ESCUDARÓN DE ASALTO SUPER PUMA</p>
                <p className="text-sm font-bold">BODEGA DE HERRAMIENTAS</p>
                <p className="text-sm font-bold text-red-500">No. {registro?.number ?? "___"}</p>
              </div>

              {/* Información del solicitante y receptor */}
              <div className="mt-4 border-b pb-2">
                <p>
                  <strong>Solicitante:</strong> {registro?.solicitante ?? "________"}
                </p>
                <p>
                  <strong>Receptor:</strong> {registro?.receptor ?? "________"}
                </p>
                <p>
                  <strong>Fecha:</strong> {registro?.fecha ?? "________"}
                </p>
              </div>

              {/* Tabla de herramientas */}
              <table className="w-full border mt-4">
                <thead>
                  <tr className="bg-gray-200">
                    <th className="border p-2">Descripción</th>
                    <th className="border p-2">Marca</th>
                    <th className="border p-2">Serie</th>
                    <th className="border p-2">Novedad</th>
                  </tr>
                </thead>
                <tbody>
                  {herramientasDetalles.length ? (
                    herramientasDetalles.map((herramienta, index) => (
                      <tr key={index} className="text-center">
                        <td className="border p-2">{herramienta.nombre}</td>
                        <td className="border p-2">{herramienta.marca}</td>
                        <td className="border p-2">{herramienta.serie}</td>
                        <td className="border p-2">Entregado</td>
                      </tr>
                    ))
                  ) : (
                    <tr>
                      <td colSpan={5} className="border p-2 text-center">
                        No hay herramientas registradas
                      </td>
                    </tr>
                  )}
                </tbody>
              </table>

              {/* Firmas */}
              <div className="mt-6 flex justify-between text-sm">
                <div className="text-center w-1/2">
                  <p>Encargado de la Bodega</p>
                  <p className="mt-12 border-t w-3/4 mx-auto">Firma</p>
                  <p>Nombre:</p>
                  <p>Cédula:</p>
                </div>
                <div className="text-center w-1/2">
                  <p>Recibí Conforme</p>
                  <p className="mt-12 border-t w-3/4 mx-auto">Firma</p>
                  <p>Nombre:</p>
                  <p>Cédula:</p>
                </div>
              </div>
            </div>

            {/* Botón de impresión */}
            <div className="text-center mt-6">
              <button
                onClick={handlePrint}
                className="bg-blue-500 text-white px-4 py-2 rounded-lg hover:bg-blue-600"
              >
                Imprimir Reporte
              </button>
            </div>
          </div>
        </div>
      </div>
    </>
  );
};

export default ReporteRegistro;




================================================
FILE: styles/global.css
================================================
@tailwind base;
@tailwind components;
@tailwind utilities;

@layer base {
  body {
    @apply bg-gray-100;;
  }
}

.tab-button {
  background-color: rgb(0, 0, 0);
  width: auto;
  height:auto;
  padding: 10px;
  color: #fff;
  margin-left: 6px;
  margin-bottom: 1em;
  margin-top: 0.5em;
  border-radius: 80ch;
  font-size: 13px;
  margin-block-start: 10px;
}
.tab-button:hover {
  background-color: #ccc!important;
}
.tab-button.active {
  background-color: #e04337!important;
}

.tab-contents {
  padding: 0.01em 16px;
}



================================================
FILE: styles/Home.module.css
================================================
.limiter {
    min-height: 100vh;
    --tw-bg-opacity: 1;
    background-color: rgb(226 232 240 / var(--tw-bg-opacity));
  }

